import { Reader } from './reader';
import { CharacterClass, CharacterClassEscape, Dot, UnicodePropertyEscape, Value } from 'regjsparser';
import { CharacterGroups } from './character-groups';
import { CharacterReaderLevel2, CharacterReaderLevel2Stack } from './character-reader/character-reader-level-2';
import { NodeExtra } from './node-extra';
export type CheckerInput = Readonly<{
    atomicGroupOffsets: ReadonlySet<number>;
    leftStreamReader: CharacterReaderLevel2;
    maxSteps: number;
    multiLine: boolean;
    rightStreamReader: CharacterReaderLevel2;
    timeout: number;
    nodeExtra: NodeExtra;
}>;
export type CharacterGroupsOrReference = Readonly<{
    groups: CharacterGroups;
    type: 'groups';
} | {
    index: number;
    type: 'reference';
}>;
export type TrailEntrySide = Readonly<{
    characterGroups: CharacterGroups;
    contextTrail: string;
    hash: string;
    node: CharacterClass | CharacterClassEscape | Dot | UnicodePropertyEscape | Value;
    stack: CharacterReaderLevel2Stack;
}>;
export type TrailEntry = Readonly<{
    intersection: CharacterGroups;
    left: TrailEntrySide;
    right: TrailEntrySide;
}>;
export type Trail = readonly TrailEntry[];
export declare const checkerReaderTypeTrail: unique symbol;
export declare const checkerReaderTypeInfiniteLoop: unique symbol;
export type CheckerReaderValueTrail = Readonly<{
    trail: Trail;
    type: typeof checkerReaderTypeTrail;
}>;
export type CheckerReaderValue = CheckerReaderValueTrail;
export type CheckerReader = Reader<CheckerReaderValue, CheckerReaderReturn>;
export type CheckerReaderReturn = Readonly<{
    error: null;
    infinite: boolean;
} | {
    error: 'hitMaxSteps' | 'timedOut';
}>;
/**
 * Takes a left and right `CharacterReaderLevel2` and runs them against each other.
 *
 * Emits a trail when left and right differ, as it means there are 2 different ways of matching the same
 * trail up to that point.
 */
export declare function buildCheckerReader(input: CheckerInput): CheckerReader;
