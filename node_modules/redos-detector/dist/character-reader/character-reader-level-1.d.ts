import { CharacterReaderValueSplitSubType, Stack } from './character-reader-level-0';
import { CharacterClass, CharacterClassEscape, Dot, Reference, UnicodePropertyEscape, Value } from 'regjsparser';
import { Reader } from '../reader';
import { CharacterGroups } from '../character-groups';
import { MyRootNode } from '../parse';
export declare const characterReaderLevel1TypeSplit: unique symbol;
export declare const characterReaderLevel1TypeEntry: unique symbol;
export type CharacterReaderLevel1ValueSplit = Readonly<{
    reader: () => CharacterReaderLevel1;
    subType: CharacterReaderValueSplitSubType;
    type: typeof characterReaderLevel1TypeSplit;
}>;
export type ZeroWidthEntry = Readonly<{
    offset: number;
    type: 'null';
} | {
    offset: number;
    type: 'start';
}>;
export type CharacterReaderLevel1ValueEntryBase = Readonly<{
    precedingZeroWidthEntries: readonly ZeroWidthEntry[];
    stack: Stack;
    type: typeof characterReaderLevel1TypeEntry;
}>;
export type CharacterReaderLevel1ValueEntryGroups = Readonly<CharacterReaderLevel1ValueEntryBase & {
    characterGroups: CharacterGroups;
    node: CharacterClass | CharacterClassEscape | Dot | UnicodePropertyEscape | Value;
    subType: 'groups';
}>;
export type CharacterReaderLevel1ValueEntryReference = Readonly<CharacterReaderLevel1ValueEntryBase & {
    node: Reference;
    referenceIndex: number;
    subType: 'reference';
}>;
export type CharacterReaderLevel1ValueEntry = CharacterReaderLevel1ValueEntryGroups | CharacterReaderLevel1ValueEntryReference;
export type CharacterReaderLevel1Value = CharacterReaderLevel1ValueEntry | CharacterReaderLevel1ValueSplit;
export type CharacterReaderLevel1ReturnValue = Readonly<{
    bounded: boolean;
    precedingZeroWidthEntries: readonly ZeroWidthEntry[];
}>;
export type CharacterReaderLevel1 = Reader<CharacterReaderLevel1Value, CharacterReaderLevel1ReturnValue>;
/**
 * Returns a `CharacterReaderLevel1` which builds on top of
 * `CharacterReaderLevel0` adds a `precedingZeroWidthEntries` property
 * and makes every result map to a character.
 */
export declare function buildCharacterReaderLevel1({ caseInsensitive, dotAll, node, }: {
    caseInsensitive: boolean;
    dotAll: boolean;
    node: MyRootNode;
}): CharacterReaderLevel1;
