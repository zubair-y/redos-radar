/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var parser = {exports: {}};

(function (module) {
	(function() {

	  var fromCodePoint = String.fromCodePoint || (function() {
	    // Implementation taken from
	    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint

	    var stringFromCharCode = String.fromCharCode;
	    var floor = Math.floor;

	    return function fromCodePoint() {
	      var MAX_SIZE = 0x4000;
	      var codeUnits = [];
	      var highSurrogate;
	      var lowSurrogate;
	      var index = -1;
	      var length = arguments.length;
	      if (!length) {
	        return '';
	      }
	      var result = '';
	      while (++index < length) {
	        var codePoint = Number(arguments[index]);
	        if (
	          !isFinite(codePoint) ||       // `NaN`, `+Infinity`, or `-Infinity`
	          codePoint < 0 ||              // not a valid Unicode code point
	          codePoint > 0x10FFFF ||       // not a valid Unicode code point
	          floor(codePoint) != codePoint // not an integer
	        ) {
	          throw RangeError('Invalid code point: ' + codePoint);
	        }
	        if (codePoint <= 0xFFFF) { // BMP code point
	          codeUnits.push(codePoint);
	        } else { // Astral code point; split in surrogate halves
	          // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	          codePoint -= 0x10000;
	          highSurrogate = (codePoint >> 10) + 0xD800;
	          lowSurrogate = (codePoint % 0x400) + 0xDC00;
	          codeUnits.push(highSurrogate, lowSurrogate);
	        }
	        if (index + 1 == length || codeUnits.length > MAX_SIZE) {
	          result += stringFromCharCode.apply(null, codeUnits);
	          codeUnits.length = 0;
	        }
	      }
	      return result;
	    };
	  }());

	  function parse(str, flags, features) {
	    if (!features) {
	      features = {};
	    }

	    function updateRawStart(node, start) {
	      node.range[0] = start;
	      node.raw = str.substring(start, node.range[1]);
	      return node;
	    }

	    function createAnchor(kind, rawLength) {
	      return {
	        type: 'anchor',
	        kind: kind,
	        range: [
	          pos - rawLength,
	          pos
	        ],
	        raw: str.substring(pos - rawLength, pos)
	      };
	    }

	    function createValue(kind, codePoint, from, to) {
	      return {
	        type: 'value',
	        kind: kind,
	        codePoint: codePoint,
	        range: [from, to],
	        raw: str.substring(from, to)
	      };
	    }

	    function createEscaped(kind, codePoint, value, fromOffset) {
	      fromOffset = fromOffset || 0;
	      return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
	    }

	    function createCharacter(matches) {
	      var _char = matches[0];
	      var first = _char.charCodeAt(0);
	      if (isUnicodeMode) {
	        var second;
	        if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {
	          second = lookahead().charCodeAt(0);
	          if (second >= 0xDC00 && second <= 0xDFFF) {
	            // Unicode surrogate pair
	            pos++;
	            return createValue(
	              'symbol',
	              (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000,
	              pos - 2, pos);
	          }
	        }
	      }
	      return createValue('symbol', first, pos - 1, pos);
	    }

	    function createDisjunction(alternatives, from, to) {
	      return {
	        type: 'disjunction',
	        body: alternatives,
	        range: [
	          from,
	          to
	        ],
	        raw: str.substring(from, to)
	      };
	    }

	    function createDot() {
	      return {
	        type: 'dot',
	        range: [
	          pos - 1,
	          pos
	        ],
	        raw: '.'
	      };
	    }

	    function createCharacterClassEscape(value) {
	      return {
	        type: 'characterClassEscape',
	        value: value,
	        range: [
	          pos - 2,
	          pos
	        ],
	        raw: str.substring(pos - 2, pos)
	      };
	    }

	    function createReference(matchIndex) {
	      var start = pos - 1 - matchIndex.length;
	      return {
	        type: 'reference',
	        matchIndex: parseInt(matchIndex, 10),
	        range: [
	          start,
	          pos
	        ],
	        raw: str.substring(start, pos)
	      };
	    }

	    function createNamedReference(name) {
	      var start = name.range[0] - 3;
	      return {
	        type: 'reference',
	        name: name,
	        range: [
	          start,
	          pos
	        ],
	        raw: str.substring(start, pos)
	      };
	    }

	    function createGroup(behavior, disjunction, from, to) {
	      return {
	        type: 'group',
	        behavior: behavior,
	        body: disjunction,
	        range: [
	          from,
	          to
	        ],
	        raw: str.substring(from, to)
	      };
	    }

	    function createQuantifier(min, max, from, to, symbol) {
	      if (to == null) {
	        from = pos - 1;
	        to = pos;
	      }

	      return {
	        type: 'quantifier',
	        min: min,
	        max: max,
	        greedy: true,
	        body: null, // set later on
	        symbol: symbol,
	        range: [
	          from,
	          to
	        ],
	        raw: str.substring(from, to)
	      };
	    }

	    function createAlternative(terms, from, to) {
	      return {
	        type: 'alternative',
	        body: terms,
	        range: [
	          from,
	          to
	        ],
	        raw: str.substring(from, to)
	      };
	    }

	    function createCharacterClass(contents, negative, from, to) {
	      return {
	        type: 'characterClass',
	        kind: contents.kind,
	        body: contents.body,
	        negative: negative,
	        range: [
	          from,
	          to
	        ],
	        raw: str.substring(from, to)
	      };
	    }

	    function createClassRange(min, max, from, to) {
	      // See 15.10.2.15:
	      if (min.codePoint > max.codePoint) {
	        bail('invalid range in character class', min.raw + '-' + max.raw, from, to);
	      }

	      return {
	        type: 'characterClassRange',
	        min: min,
	        max: max,
	        range: [
	          from,
	          to
	        ],
	        raw: str.substring(from, to)
	      };
	    }

	    function createClassStrings(strings, from, to) {
	      return {
	        type: 'classStrings',
	        strings: strings,
	        range: [from, to],
	        raw: str.substring(from, to)
	      };
	    }

	    function createClassString(characters, from, to) {
	      return {
	        type: 'classString',
	        characters: characters,
	        range: [from, to],
	        raw: str.substring(from, to)
	      };
	    }

	    function flattenBody(body) {
	      if (body.type === 'alternative') {
	        return body.body;
	      } else {
	        return [body];
	      }
	    }

	    function incr(amount) {
	      amount = (amount || 1);
	      pos += amount;
	    }

	    function consume(amount) {
	      var res = str.substring(pos, pos += amount);
	      return res;
	    }

	    function skip(value) {
	      if (!match(value)) {
	        bail('character', value);
	      }
	    }

	    function match(value) {
	      var len = value.length;
	      if (str.substring(pos, pos + len) === value) {
	        incr(len);
	        return value;
	      }
	    }

	    function matchOne(value) {
	      if (str[pos] === value) {
	        pos++;
	        return value;
	      }
	    }

	    function lookahead() {
	      return str[pos];
	    }

	    function currentOne(value) {
	      return str[pos] === value;
	    }

	    function current(value) {
	      var len = value.length;
	      return str.substring(pos, pos + len) === value;
	    }

	    function next(value) {
	      return str[pos + 1] === value;
	    }

	    function matchReg(regExp) {
	      var subStr = str.substring(pos);
	      var res = subStr.match(regExp);
	      if (res) {
	        pos += res[0].length;
	      }
	      return res;
	    }

	    function parseDisjunction() {
	      // Disjunction ::
	      //      Alternative
	      //      Alternative | Disjunction
	      var res = [], from = pos;
	      res.push(parseAlternative());

	      while (matchOne('|')) {
	        res.push(parseAlternative());
	      }

	      if (res.length === 1) {
	        return res[0];
	      }

	      return createDisjunction(res, from, pos);
	    }

	    function parseAlternative() {
	      var res = [], from = pos;
	      var term;

	      // Alternative ::
	      //      [empty]
	      //      Alternative Term
	      while (term = parseTerm()) {
	        res.push(term);
	      }

	      if (res.length === 1) {
	        return res[0];
	      }

	      return createAlternative(res, from, pos);
	    }

	    function parseTerm() {
	      // Term ::
	      //      Anchor
	      //      Atom
	      //      Atom Quantifier

	      // Term (Annex B)::
	      //      [~UnicodeMode] QuantifiableAssertion Quantifier (see https://github.com/jviereck/regjsparser/issues/130)
	      //      [~UnicodeMode] ExtendedAtom Quantifier

	      // QuantifiableAssertion::
	      //      (?= Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] )
	      //      (?! Disjunction[~UnicodeMode, ~UnicodeSetsMode, ?NamedCaptureGroups] ) 

	      if (pos >= str.length || currentOne('|') || currentOne(')')) {
	        return null; /* Means: The term is empty */
	      }

	      var anchor = parseAnchor();
	      var quantifier;
	      if (anchor) {
	        var pos_backup = pos;
	        quantifier = parseQuantifier() || false;
	        if (quantifier) {
	          // Annex B
	          if (!isUnicodeMode && anchor.type === "group") {
	            quantifier.body = flattenBody(anchor);
	            // The quantifier contains the anchor. Therefore, the beginning of the
	            // quantifier range is given by the beginning of the anchor.
	            updateRawStart(quantifier, anchor.range[0]);
	            return quantifier;
	          }
	          pos = pos_backup;
	          bail("Expected atom");
	        }
	        return anchor;
	      }

	      // If there is no Anchor, try to parse an atom.
	      var atom = parseAtomAndExtendedAtom();
	      if (!atom) {
	        // Check if a quantifier is following. A quantifier without an atom
	        // is an error.
	        pos_backup = pos;
	        quantifier = parseQuantifier() || false;
	        if (quantifier) {
	          pos = pos_backup;
	          bail("Expected atom");
	        }

	        // If no unicode flag, then try to parse ExtendedAtom -> ExtendedPatternCharacter.
	        //      ExtendedPatternCharacter
	        if (!isUnicodeMode && matchOne("{")) {
	          atom = createCharacter("{");
	        } else {
	          bail("Expected atom");
	        }
	      }

	      quantifier = parseQuantifier() || false;
	      if (quantifier) {
	        var type = atom.type, behavior = atom.behavior;
	        if (
	          type === "group" &&
	          (behavior === "negativeLookbehind" ||
	            behavior === "lookbehind")
	        ) {
	          bail(
	            "Invalid quantifier",
	            "",
	            quantifier.range[0],
	            quantifier.range[1]
	          );
	        }
	        quantifier.body = flattenBody(atom);
	        // The quantifier contains the atom. Therefore, the beginning of the
	        // quantifier range is given by the beginning of the atom.
	        updateRawStart(quantifier, atom.range[0]);
	        return quantifier;
	      }
	      return atom;
	    }

	    function parseGroup(matchA, typeA, matchB, typeB) {
	      var type = null, from = pos;

	      if (match(matchA)) {
	        type = typeA;
	      } else if (match(matchB)) {
	        type = typeB;
	      } else {
	        return false;
	      }

	      return finishGroup(type, from);
	    }

	    function finishGroup(type, from) {
	      var body = parseDisjunction();
	      if (!body) {
	        bail('Expected disjunction');
	      }
	      skip(')');
	      var group = createGroup(type, flattenBody(body), from, pos);

	      if (type == 'normal') {
	        // Keep track of the number of closed groups. This is required for
	        // parseDecimalEscape(). In case the string is parsed a second time the
	        // value already holds the total count and no incrementation is required.
	        if (firstIteration) {
	          closedCaptureCounter++;
	        }
	      }
	      return group;
	    }

	    function parseAnchor() {
	      // Anchor ::
	      //      ^
	      //      $
	      //      \ b
	      //      \ B
	      //      ( ? = Disjunction )
	      //      ( ? ! Disjunction )

	      switch(lookahead()) {
	        case '^':
	          incr();
	          return createAnchor('start', 1 /* rawLength */);
	        case '$':
	          incr();
	          return createAnchor('end', 1 /* rawLength */);
	        case '\\': {
	          if (next('b')) {
	            incr(2);
	            return createAnchor('boundary', 2 /* rawLength */);
	          } else if (next('B')) {
	            incr(2);
	            return createAnchor('not-boundary', 2 /* rawLength */);
	          }
	          break;
	        }
	        case '(':
	          return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');
	        default:
	          return;
	      }
	    }

	    function parseQuantifier() {
	      // Quantifier ::
	      //      QuantifierPrefix
	      //      QuantifierPrefix ?
	      //
	      // QuantifierPrefix ::
	      //      *
	      //      +
	      //      ?
	      //      { DecimalDigits }
	      //      { DecimalDigits , }
	      //      { DecimalDigits , DecimalDigits }

	      var res, from = pos;
	      var quantifier;
	      var min, max;

	      switch(lookahead()) {
	        case '*':
	          incr();
	          quantifier = createQuantifier(0, undefined, undefined, undefined, '*');
	          break;
	        case '+':
	          incr();
	          quantifier = createQuantifier(1, undefined, undefined, undefined, "+");
	          break;
	        case '?':
	          incr();
	          quantifier = createQuantifier(0, 1, undefined, undefined, "?");
	          break;
	        case '{': {
	          if (res = matchReg(/^\{(\d+)\}/)) {
	            min = parseInt(res[1], 10);
	            quantifier = createQuantifier(min, min, from, pos);
	          }
	          else if (res = matchReg(/^\{(\d+),\}/)) {
	            min = parseInt(res[1], 10);
	            quantifier = createQuantifier(min, undefined, from, pos);
	          }
	          else if (res = matchReg(/^\{(\d+),(\d+)\}/)) {
	            min = parseInt(res[1], 10);
	            max = parseInt(res[2], 10);
	            if (min > max) {
	              bail('numbers out of order in {} quantifier', '', from, pos);
	            }
	            quantifier = createQuantifier(min, max, from, pos);
	          }
	    
	          if (min && (!Number.isSafeInteger(min)) || (max && !Number.isSafeInteger(max))) {
	            bail("iterations outside JS safe integer range in quantifier", "", from, pos);
	          }
	        }
	      } 

	      if (quantifier) {
	        if (matchOne('?')) {
	          quantifier.greedy = false;
	          quantifier.range[1] += 1;
	        }
	      }

	      return quantifier;
	    }

	    function parseAtomAndExtendedAtom() {
	      // Parsing Atom and ExtendedAtom together due to redundancy.
	      // ExtendedAtom is defined in Apendix B of the ECMA-262 standard.
	      //
	      // SEE: https://www.ecma-international.org/ecma-262/10.0/index.html#prod-annexB-ExtendedPatternCharacter
	      //
	      // Atom ::
	      //      PatternCharacter
	      //      .
	      //      \ AtomEscape
	      //      CharacterClass
	      //      ( GroupSpecifier Disjunction )
	      //      ( ? RegularExpressionModifiers : Disjunction )
	      //      ( ? RegularExpressionModifiers - RegularExpressionModifiers : Disjunction )
	      // ExtendedAtom ::
	      //      ExtendedPatternCharacter
	      // ExtendedPatternCharacter ::
	      //      SourceCharacter but not one of ^$\.*+?()[|

	      var res;

	      switch (res = lookahead()) {
	        case '.':
	          //      .
	          incr();
	          return createDot();
	        case '\\': {
	          //      \ AtomEscape
	          incr();
	          res = parseAtomEscape();
	          if (!res) {
	            if (!isUnicodeMode && lookahead() == 'c') {
	              // B.1.4 ExtendedAtom
	              // \[lookahead = c]
	              return createValue('symbol', 92, pos - 1, pos);
	            }
	            bail('atomEscape');
	          }
	          return res;
	        }
	        case '[':
	          return parseCharacterClass();
	        case '(': {
	          if (features.lookbehind && (res = parseGroup('(?<=', 'lookbehind', '(?<!', 'negativeLookbehind'))) {
	            return res;
	          }
	          else if (features.namedGroups && match("(?<")) {
	            var name = parseIdentifier();
	            skip(">");
	            var group = finishGroup("normal", name.range[0] - 3);
	            group.name = name;
	            return group;
	          }
	          else if (features.modifiers && current("(?") && str[pos + 2] != ":") {
	            return parseModifiersGroup();
	          }
	          else {
	            //      ( Disjunction )
	            //      ( ? : Disjunction )
	            return parseGroup('(?:', 'ignore', '(', 'normal');
	          }
	        }
	        case ']':
	        case '}':
	          //      ExtendedPatternCharacter, first part. See parseTerm.
	          if (!isUnicodeMode) {
	            incr();
	            return createCharacter(res);
	          }
	          break;
	        case '^':
	        case '$':
	        case '*':
	        case '+':
	        case '?':
	        case '{':
	        case ')':
	        case '|':
	          break;
	        default:
	          //      PatternCharacter
	          incr();
	          return createCharacter(res);
	      }
	    }

	    function parseModifiersGroup() {
	      function hasDupChar(str) {
	        var i = 0;
	        while (i < str.length) {
	          if (str.indexOf(str[i], i + 1) != -1) {
	            return true;
	          }
	          i++;
	        }
	        return false;
	      }

	      var from = pos;
	      incr(2);

	      var enablingFlags = matchReg(/^[sim]+/);
	      var disablingFlags;
	      if(matchOne("-") && lookahead() !== ":"){
	        disablingFlags = matchReg(/^[sim]+/);
	        if (!disablingFlags) {
	          bail('Invalid flags for modifiers group');
	        }
	      } else if(!enablingFlags){
	        bail('Invalid flags for modifiers group');
	      }

	      enablingFlags = enablingFlags ? enablingFlags[0] : "";
	      disablingFlags = disablingFlags ? disablingFlags[0] : "";

	      var flags = enablingFlags + disablingFlags;
	      if(flags.length > 3 || hasDupChar(flags)) {
	        bail('flags cannot be duplicated for modifiers group');
	      }

	      if(!matchOne(":")) {
	        bail('Invalid flags for modifiers group');
	      }

	      var modifiersGroup = finishGroup("ignore", from);

	      modifiersGroup.modifierFlags = {
	        enabling: enablingFlags,
	        disabling: disablingFlags
	      };

	      return modifiersGroup;
	    }

	    function parseUnicodeSurrogatePairEscape(firstEscape, isUnicodeMode) {
	      if (isUnicodeMode) {
	        var first, second;
	        if (firstEscape.kind == 'unicodeEscape' &&
	          (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF &&
	          currentOne('\\') && next('u') ) {
	          var prevPos = pos;
	          pos++;
	          var secondEscape = parseClassEscape();
	          if (secondEscape.kind == 'unicodeEscape' &&
	            (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {
	            // Unicode surrogate pair
	            firstEscape.kind = 'unicodeCodePointEscape';
	            firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            firstEscape.range[1] = pos;
	            firstEscape.raw = str.substring(firstEscape.range[0], pos);
	          }
	          else {
	            pos = prevPos;
	          }
	        }
	      }
	      return firstEscape;
	    }

	    function parseClassEscape() {
	      return parseAtomEscape(true);
	    }

	    function parseAtomEscape(insideCharacterClass) {
	      // AtomEscape ::
	      //      DecimalEscape
	      //      CharacterEscape
	      //      CharacterClassEscape
	      //      k GroupName

	      var res, from = pos, ch;

	      switch (ch = lookahead()) {
	        case '0':
	        case '1':
	        case '2':
	        case '3':
	        case '4':
	        case '5':
	        case '6':
	        case '7':
	        case '8':
	        case '9':
	          return parseDecimalEscape(insideCharacterClass);
	        case 'B': {
	          if (insideCharacterClass) {
	            bail('\\B not possible inside of CharacterClass', '', from);
	            break;
	          } else {
	            return parseIdentityEscape();
	          }
	        }
	        case 'b': {
	          if (insideCharacterClass) {
	            // 15.10.2.19
	            // The production ClassEscape :: b evaluates by returning the
	            // CharSet containing the one character <BS> (Unicode value 0008).
	            incr();
	            return createEscaped('singleEscape', 0x0008, '\\b');
	          } else {
	            return parseIdentityEscape();
	          }
	        }
	        case 'c': {
	          if (insideCharacterClass) {
	            if (!isUnicodeMode && (res = matchReg(/^c(\d)/))) {
	              // B.1.4
	              // c ClassControlLetter, ClassControlLetter = DecimalDigit
	              return createEscaped('controlLetter', res[1] + 16, res[1], 2);
	            } else if (!isUnicodeMode && match("c_")) {
	              // B.1.4
	              // c ClassControlLetter, ClassControlLetter = _
	              return createEscaped('controlLetter', 31, '_', 2);
	            }
	          }
	          return parseCharacterEscape();
	        }
	        // CharacterClassEscape :: one of d D s S w W
	        case 'd':
	        case 'D':
	        case 'w':
	        case 'W':
	        case 's':
	        case 'S':
	          incr();
	          return createCharacterClassEscape(ch);
	        case 'k':
	          return parseNamedReference() || parseIdentityEscape();
	        case 'p':
	        case 'P':
	          return parseUnicodePropertyEscape() || parseIdentityEscape();
	        case '-': {
	          //     [+U] -
	          if (insideCharacterClass && isUnicodeMode) {
	            incr();
	            return createEscaped('singleEscape', 0x002d, '\\-');
	          }
	          return parseIdentityEscape();
	        }
	        default:
	          return parseCharacterEscape();
	      }
	    }


	    function parseDecimalEscape(insideCharacterClass) {
	      // DecimalEscape ::
	      //      DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

	      var res, match, from = pos;

	      if (res = matchReg(/^(?!0)\d+/)) {
	        match = res[0];
	        var refIdx = parseInt(res[0], 10);
	        if (refIdx <= closedCaptureCounter && !insideCharacterClass) {
	          // If the number is smaller than the normal-groups found so
	          // far, then it is a reference...
	          return createReference(res[0]);
	        } else {
	          // ... otherwise it needs to be interpreted as a octal (if the
	          // number is in an octal format). If it is NOT octal format,
	          // then the slash is ignored and the number is matched later
	          // as normal characters.

	          // Recall the negative decision to decide if the input must be parsed
	          // a second time with the total normal-groups.
	          backrefDenied.push(refIdx);

	          // \1 octal escapes are disallowed in unicode mode, but they might
	          // be references to groups which haven't been parsed yet.
	          // We must parse a second time to determine if \1 is a reference
	          // or an octal scape, and then we can report the error.
	          if (firstIteration) {
	            shouldReparse = true;
	          } else {
	            bailOctalEscapeIfUnicode(from, pos);
	          }

	          // Reset the position again, as maybe only parts of the previous
	          // matched numbers are actual octal numbers. E.g. in '019' only
	          // the '01' should be matched.
	          incr(-res[0].length);
	          if (res = matchReg(/^[0-7]{1,3}/)) {
	            return createEscaped('octal', parseInt(res[0], 8), res[0], 1);
	          } else {
	            // If we end up here, we have a case like /\91/. Then the
	            // first slash is to be ignored and the 9 & 1 to be treated
	            // like ordinary characters. Create a character for the
	            // first number only here - other number-characters
	            // (if available) will be matched later.
	            var start = pos;
	            res = createCharacter(matchReg(/^[89]/));
	            return updateRawStart(res, start - 1);
	          }
	        }
	      }
	      // Only allow octal numbers in the following. All matched numbers start
	      // with a zero (if the do not, the previous if-branch is executed).
	      // If the number is not octal format and starts with zero (e.g. `091`)
	      // then only the zeros `0` is treated here and the `91` are ordinary
	      // characters.
	      // Example:
	      //   /\091/.exec('\091')[0].length === 3
	      else if (res = matchReg(/^[0-7]{1,3}/)) {
	        match = res[0];
	        if (match !== '0') {
	          bailOctalEscapeIfUnicode(from, pos);
	        }
	        if (/^0{1,3}$/.test(match)) {
	          // If they are all zeros, then only take the first one.
	          return createEscaped('null', 0x0000, '0', match.length);
	        } else {
	          return createEscaped('octal', parseInt(match, 8), match, 1);
	        }
	      }
	      return false;
	    }

	    function bailOctalEscapeIfUnicode(from, pos) {
	      if (isUnicodeMode) {
	        bail("Invalid decimal escape in unicode mode", null, from, pos);
	      }
	    }

	    function parseUnicodePropertyEscape() {
	      var res, from = pos;
	      if (features.unicodePropertyEscape && isUnicodeMode && (res = matchReg(/^([pP])\{([^}]+)\}/))) {
	        // https://github.com/jviereck/regjsparser/issues/77
	        return {
	          type: 'unicodePropertyEscape',
	          negative: res[1] === 'P',
	          value: res[2],
	          range: [from - 1, pos],
	          raw: str.substring(from - 1, pos)
	        };
	      }
	      return false;
	    }

	    function parseNamedReference() {
	      if (features.namedGroups && matchReg(/^k<(?=.*?>)/)) {
	        var name = parseIdentifier();
	        skip('>');
	        return createNamedReference(name);
	      }
	    }

	    function parseRegExpUnicodeEscapeSequence(isUnicodeMode) {
	      var res;
	      if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {
	        // UnicodeEscapeSequence
	        return parseUnicodeSurrogatePairEscape(
	          createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2),
	          isUnicodeMode
	        );
	      } else if (isUnicodeMode && (res = matchReg(/^u\{([0-9a-fA-F]+)\}/))) {
	        // RegExpUnicodeEscapeSequence (ES6 Unicode code point escape)
	        return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);
	      }
	    }

	    function parseCharacterEscape() {
	      // CharacterEscape ::
	      //      ControlEscape
	      //      c ControlLetter
	      //      HexEscapeSequence
	      //      UnicodeEscapeSequence[?UnicodeMode]
	      //      IdentityEscape[?UnicodeMode]

	      var res;
	      var from = pos;
	      switch (lookahead()) {
	        case 't':
	          incr();
	          return createEscaped('singleEscape', 0x009, '\\t');
	        case 'n':
	          incr();
	          return createEscaped('singleEscape', 0x00A, '\\n');
	        case 'v':
	          incr();
	          return createEscaped('singleEscape', 0x00B, '\\v');
	        case 'f':
	          incr();
	          return createEscaped('singleEscape', 0x00C, '\\f');
	        case 'r':
	          incr();
	          return createEscaped('singleEscape', 0x00D, '\\r');
	        case 'c':
	          if (res = matchReg(/^c([a-zA-Z])/)) {
	            // c ControlLetter
	            return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);
	          }
	          break;
	        case 'x':
	          if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {
	            // HexEscapeSequence
	            return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);
	          }
	          break;
	        case 'u':
	          if (res = parseRegExpUnicodeEscapeSequence(isUnicodeMode)) {
	            if (!res || res.codePoint > 0x10FFFF) {
	              bail('Invalid escape sequence', null, from, pos);
	            }
	            return res;
	          }
	          break;
	      }
	      // IdentityEscape
	      return parseIdentityEscape();
	    }

	    function parseIdentifierAtom(check) {
	      // RegExpIdentifierStart[UnicodeMode] ::
	      //      IdentifierStartChar
	      //      \ RegExpUnicodeEscapeSequence[+UnicodeMode]
	      //      [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate
	      //
	      // RegExpIdentifierPart[UnicodeMode] ::
	      //      IdentifierPartChar
	      //      \ RegExpUnicodeEscapeSequence[+UnicodeMode]
	      //      [~UnicodeMode] UnicodeLeadSurrogate UnicodeTrailSurrogate
	      
	      
	      var ch = lookahead();
	      var from = pos;
	      if (ch === '\\') {
	        incr();
	        var esc = parseRegExpUnicodeEscapeSequence(true);
	        if (!esc || !check(esc.codePoint)) {
	          bail('Invalid escape sequence', null, from, pos);
	        }
	        return fromCodePoint(esc.codePoint);
	      }
	      var code = ch.charCodeAt(0);
	      if (code >= 0xD800 && code <= 0xDBFF) {
	        ch += str[pos + 1];
	        var second = ch.charCodeAt(1);
	        if (second >= 0xDC00 && second <= 0xDFFF) {
	          // Unicode surrogate pair
	          code = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	        }
	      }
	      if (!check(code)) return;
	      incr();
	      if (code > 0xFFFF) incr();
	      return ch;
	    }

	    function parseIdentifier() {
	      // RegExpIdentifierName ::
	      //      RegExpIdentifierStart
	      //      RegExpIdentifierName RegExpIdentifierContinue
	      //
	      // RegExpIdentifierStart ::
	      //      UnicodeIDStart
	      //      $
	      //      _
	      //      \ RegExpUnicodeEscapeSequence
	      //
	      // RegExpIdentifierContinue ::
	      //      UnicodeIDContinue
	      //      $
	      //      _
	      //      \ RegExpUnicodeEscapeSequence
	      //      <ZWNJ>
	      //      <ZWJ>

	      var start = pos;
	      var res = parseIdentifierAtom(isIdentifierStart);
	      if (!res) {
	        bail('Invalid identifier');
	      }

	      var ch;
	      while (ch = parseIdentifierAtom(isIdentifierPart)) {
	        res += ch;
	      }

	      return {
	        type: 'identifier',
	        value: res,
	        range: [start, pos],
	        raw: str.substring(start, pos)
	      };
	    }

	    function isIdentifierStart(ch) {
	      // ECMAScript (Unicode v16.0.0) NonAsciiIdentifierStart:
	      // Generated by `tools/generate-identifier-regex.js`.

	      var NonAsciiIdentifierStart = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDD4A-\uDD65\uDD6F-\uDD85\uDE80-\uDEA9\uDEB0\uDEB1\uDEC2-\uDEC4\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7\uDFD1\uDFD3]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD1D]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDDD0-\uDDED\uDDF0\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF]/;

	      return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
	        (ch >= 65 && ch <= 90) ||         // A..Z
	        (ch >= 97 && ch <= 122) ||        // a..z
	        ((ch >= 0x80) && NonAsciiIdentifierStart.test(fromCodePoint(ch)));
	    }

	    // Taken from the Esprima parser.
	    function isIdentifierPart(ch) {
	      // ECMAScript (Unicode v16.0.0) NonAsciiIdentifierPartOnly:
	      // Generated by `tools/generate-identifier-regex.js`.
	      // eslint-disable-next-line no-misleading-character-class
	      var NonAsciiIdentifierPartOnly = /[\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDD30-\uDD39\uDD40-\uDD49\uDD69-\uDD6D\uDEAB\uDEAC\uDEFC-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC66-\uDC70\uDC73\uDC74\uDC7F-\uDC82\uDCB0-\uDCBA\uDCC2\uDCF0-\uDCF9\uDD00-\uDD02\uDD27-\uDD34\uDD36-\uDD3F\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDCE-\uDDD9\uDE2C-\uDE37\uDE3E\uDE41\uDEDF-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74\uDFB8-\uDFC0\uDFC2\uDFC5\uDFC7-\uDFCA\uDFCC-\uDFD0\uDFD2\uDFE1\uDFE2]|\uD805[\uDC35-\uDC46\uDC50-\uDC59\uDC5E\uDCB0-\uDCC3\uDCD0-\uDCD9\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDE50-\uDE59\uDEAB-\uDEB7\uDEC0-\uDEC9\uDED0-\uDEE3\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDC2C-\uDC3A\uDCE0-\uDCE9\uDD30-\uDD35\uDD37\uDD38\uDD3B-\uDD3E\uDD40\uDD42\uDD43\uDD50-\uDD59\uDDD1-\uDDD7\uDDDA-\uDDE0\uDDE4\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99\uDFF0-\uDFF9]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC50-\uDC59\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD50-\uDD59\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDDA0-\uDDA9\uDEF3-\uDEF6\uDF00\uDF01\uDF03\uDF34-\uDF3A\uDF3E-\uDF42\uDF50-\uDF5A]|\uD80D[\uDC40\uDC47-\uDC55]|\uD818[\uDD1E-\uDD39]|\uD81A[\uDE60-\uDE69\uDEC0-\uDEC9\uDEF0-\uDEF4\uDF30-\uDF36\uDF50-\uDF59]|\uD81B[\uDD70-\uDD79\uDF4F\uDF51-\uDF87\uDF8F-\uDF92\uDFE4\uDFF0\uDFF1]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDCF0-\uDCF9\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDD40-\uDD49\uDEAE\uDEEC-\uDEF9]|\uD839[\uDCEC-\uDCF9\uDDEE\uDDEF\uDDF1-\uDDFA]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A\uDD50-\uDD59]|\uD83E[\uDFF0-\uDFF9]|\uDB40[\uDD00-\uDDEF]/;

	      return isIdentifierStart(ch) ||
	        (ch >= 48 && ch <= 57) ||         // 0..9
	        ((ch >= 0x80) && NonAsciiIdentifierPartOnly.test(fromCodePoint(ch)));
	    }

	    function parseIdentityEscape() {
	      // IdentityEscape ::
	      //      [+U] SyntaxCharacter
	      //      [+U] /
	      //      [~U] SourceCharacterIdentityEscape[?N]
	      // SourceCharacterIdentityEscape[?N] ::
	      //      [~N] SourceCharacter but not c
	      //      [+N] SourceCharacter but not one of c or k


	      var tmp;
	      var l = lookahead();
	      if (
	        (isUnicodeMode && /[\^$.*+?()\\[\]{}|/]/.test(l)) ||
	        (!isUnicodeMode && l !== "c")
	      ) {
	        if (l === "k" && features.lookbehind) {
	          return null;
	        }
	        tmp = consume(1);
	        return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);
	      }

	      return null;
	    }

	    function parseCharacterClass() {
	      // CharacterClass ::
	      //      [ [lookahead ∉ {^}] ClassContents ]
	      //      [ ^ ClassContents ]

	      var res, from = pos;
	      if (res = match("[^")) {
	        res = parseClassContents();
	        skip(']');
	        return createCharacterClass(res, true, from, pos);
	      } else if (matchOne('[')) {
	        res = parseClassContents();
	        skip(']');
	        return createCharacterClass(res, false, from, pos);
	      }

	      return null;
	    }

	    function parseClassContents() {
	      // ClassContents ::
	      //      [empty]
	      //      [~V] NonemptyClassRanges
	      //      [+V] ClassSetExpression

	      var res;
	      if (currentOne(']')) {
	        // Empty array means nothing inside of the ClassRange.
	        return { kind: 'union', body: [] };
	      } else if (hasUnicodeSetFlag) {
	        return parseClassSetExpression();
	      } else {
	        res = parseNonemptyClassRanges();
	        if (!res) {
	          bail('nonEmptyClassRanges');
	        }
	        return { kind: 'union', body: res };
	      }
	    }

	    function parseHelperClassContents(atom) {
	      var from, to, res, atomTo, dash;
	      if (currentOne('-') && !next(']')) {
	        // ClassAtom - ClassAtom ClassContents
	        from = atom.range[0];
	        incr();
	        dash = createCharacter('-');

	        atomTo = parseClassAtom();
	        if (!atomTo) {
	          bail('classAtom');
	        }
	        to = pos;

	        // Parse the next class range if exists.
	        var classContents = parseClassContents();
	        if (!classContents) {
	          bail('classContents');
	        }

	        // Check if both the from and atomTo have codePoints.
	        if (!('codePoint' in atom) || !('codePoint' in atomTo)) {
	          if (!isUnicodeMode) {
	            // If not, don't create a range but treat them as
	            // `atom` `-` `atom` instead.
	            //
	            // SEE: https://tc39.es/ecma262/#sec-regular-expression-patterns-semantics
	            //   NonemptyClassRanges::ClassAtom - ClassAtom ClassContents
	            //   CharacterRangeOrUnion
	            res = [atom, dash, atomTo];
	          } else {
	            // With unicode flag, both sides must have codePoints if
	            // one side has a codePoint.
	            //
	            // SEE: https://tc39.es/ecma262/#sec-patterns-static-semantics-early-errors
	            //   NonemptyClassRanges :: ClassAtom - ClassAtom ClassContents
	            bail('invalid character class');
	          }
	        } else {
	          res = [createClassRange(atom, atomTo, from, to)];
	        }

	        if (classContents.type === 'empty') {
	          return res;
	        }
	        return res.concat(classContents.body);
	      }

	      res = parseNonemptyClassRangesNoDash();
	      if (!res) {
	        bail('nonEmptyClassRangesNoDash');
	      }

	      return [atom].concat(res);
	    }

	    function parseNonemptyClassRanges() {
	      // NonemptyClassRanges ::
	      //      ClassAtom
	      //      ClassAtom NonemptyClassRangesNoDash
	      //      ClassAtom - ClassAtom ClassContents

	      var atom = parseClassAtom();
	      if (!atom) {
	        bail('classAtom');
	      }

	      if (currentOne(']')) {
	        // ClassAtom
	        return [atom];
	      }

	      // ClassAtom NonemptyClassRangesNoDash
	      // ClassAtom - ClassAtom ClassContents
	      return parseHelperClassContents(atom);
	    }

	    function parseNonemptyClassRangesNoDash() {
	      // NonemptyClassRangesNoDash ::
	      //      ClassAtom
	      //      ClassAtomNoDash NonemptyClassRangesNoDash
	      //      ClassAtomNoDash - ClassAtom ClassContents

	      var res = parseClassAtom();
	      if (!res) {
	        bail('classAtom');
	      }
	      if (currentOne(']')) {
	        //      ClassAtom
	        return res;
	      }

	      // ClassAtomNoDash NonemptyClassRangesNoDash
	      // ClassAtomNoDash - ClassAtom ClassContents
	      return parseHelperClassContents(res);
	    }

	    function parseClassAtom() {
	      // ClassAtom ::
	      //      -
	      //      ClassAtomNoDash
	      if (matchOne('-')) {
	        return createCharacter('-');
	      } else {
	        return parseClassAtomNoDash();
	      }
	    }

	    function parseClassAtomNoDash() {
	      // ClassAtomNoDash ::
	      //      SourceCharacter but not one of \ or ] or -
	      //      \ ClassEscape
	      //
	      // ClassAtomNoDash (Annex B)::
	      //      \ [lookahead = c] 

	      var res;
	      switch ((res = lookahead())) {
	        case "\\": {
	          incr();
	          res = parseClassEscape();
	          if (!res) {
	            if (!isUnicodeMode && lookahead() == "c") {
	              return createCharacter("\\");
	            }
	            bail("classEscape");
	          }

	          return parseUnicodeSurrogatePairEscape(res, isUnicodeMode);
	        }
	        case "]":
	        case "-":
	          break;
	        default:
	          incr();
	          return createCharacter(res);
	      }
	    }

	    function parseClassSetExpression() {
	      // ClassSetExpression ::
	      //      ClassUnion
	      //      ClassIntersection
	      //      ClassSubtraction
	      //
	      // ClassUnion ::
	      //      ClassSetRange ClassUnion?
	      //      ClassSetOperand ClassUnion?
	      //
	      // ClassIntersection ::
	      //      ClassSetOperand && [lookahead ≠ &] ClassSetOperand
	      //      ClassIntersection && [lookahead ≠ &] ClassSetOperand
	      //
	      // ClassSubtraction ::
	      //      ClassSetOperand -- ClassSetOperand
	      //      ClassSubtraction -- ClassSetOperand
	      //

	      var body = [];
	      var kind;

	      var operand = parseClassSetOperand(/* allowRanges*/ true);
	      body.push(operand);

	      if (operand.type === 'classRange') {
	        kind = 'union';
	      } else if (currentOne('&')) {
	        kind = 'intersection';
	      } else if (currentOne('-')) {
	        kind = 'subtraction';
	      } else {
	        kind = 'union';
	      }

	      while (!currentOne(']')) {
	        if (kind === 'intersection') {
	          skip('&');
	          skip('&');
	          if (currentOne('&')) {
	            bail('&& cannot be followed by &. Wrap it in brackets: &&[&].');
	          }
	        } else if (kind === 'subtraction') {
	          skip('-');
	          skip('-');
	        }

	        operand = parseClassSetOperand(/* allowRanges*/ kind === 'union');
	        body.push(operand);
	      }

	      return { kind: kind, body: body };
	    }

	    function parseClassSetOperand(allowRanges) {
	      // ClassSetOperand ::
	      //      ClassSetCharacter
	      //      ClassStringDisjunction
	      //      NestedClass
	      //
	      // NestedClass ::
	      //      [ [lookahead ≠ ^] ClassContents[+U,+V] ]
	      //      [ ^ ClassContents[+U,+V] ]
	      //      \ CharacterClassEscape[+U, +V]
	      //
	      // ClassSetRange ::
	      //      ClassSetCharacter - ClassSetCharacter
	      //
	      // ClassSetCharacter ::
	      //      [lookahead ∉ ClassReservedDouble] SourceCharacter but not ClassSetSyntaxCharacter
	      //      \ CharacterEscape[+U]
	      //      \ ClassHalfOfDouble
	      //      \ b
	      //
	      // ClassSyntaxCharacter ::
	      //      one of ( ) [ ] { } / - \ |

	      var from = pos;
	      var start, res;

	      if (matchOne('\\')) {
	        // ClassSetOperand ::
	        //      ...
	        //      ClassStringDisjunction
	        //      NestedClass
	        //
	        // NestedClass ::
	        //      ...
	        //      \ CharacterClassEscape[+U, +V]
	        if (match('q{')) {
	          return parseClassStringDisjunction();
	        } else if (res = parseClassEscape()) {
	          start = res;
	        } else if (res = parseClassSetCharacterEscapedHelper()) {
	          return res;
	        } else {
	          bail('Invalid escape', '\\' + lookahead(), from);
	        }
	      } else if (res = parseClassSetCharacterUnescapedHelper()) {
	        start = res;
	      } else if (res = parseCharacterClass()) {
	        // ClassSetOperand ::
	        //      ...
	        //      NestedClass
	        //
	        // NestedClass ::
	        //      [ [lookahead ≠ ^] ClassContents[+U,+V] ]
	        //      [ ^ ClassContents[+U,+V] ]
	        //      ...
	        return res;
	      } else {
	        bail('Invalid character', lookahead());
	      }

	      if (allowRanges && currentOne('-') && !next('-')) {
	        incr();

	        if (res = parseClassSetCharacter()) {
	          // ClassSetRange ::
	          //      ClassSetCharacter - ClassSetCharacter
	          return createClassRange(start, res, from, pos);
	        }

	        bail('Invalid range end', lookahead());
	      }

	      // ClassSetOperand ::
	      //      ClassSetCharacter
	      //      ...
	      return start;
	    }

	    function parseClassSetCharacter() {
	      // ClassSetCharacter ::
	      //      [lookahead ∉ ClassReservedDouble] SourceCharacter but not ClassSetSyntaxCharacter
	      //      \ CharacterEscape[+U]
	      //      \ ClassHalfOfDouble
	      //      \ b

	      if (matchOne('\\')) {
	        var res, from = pos;
	        if (res = parseClassSetCharacterEscapedHelper()) {
	          return res;
	        } else {
	          bail('Invalid escape', '\\' + lookahead(), from);
	        }
	      }

	      return parseClassSetCharacterUnescapedHelper();
	    }

	    function parseClassSetCharacterUnescapedHelper() {
	      // ClassSetCharacter ::
	      //      [lookahead ∉ ClassSetReservedDoublePunctuator] SourceCharacter but not ClassSetSyntaxCharacter
	      //      ...

	      var res;
	      if (matchReg(/^(?:&&|!!|##|\$\$|%%|\*\*|\+\+|,,|\.\.|::|;;|<<|==|>>|\?\?|@@|\^\^|``|~~)/)) {
	        bail('Invalid set operation in character class');
	      }
	      if (res = matchReg(/^[^()[\]{}/\-\\|]/)) {
	        return createCharacter(res);
	      }
	    }

	    function parseClassSetCharacterEscapedHelper() {
	      // ClassSetCharacter ::
	      //      ...
	      //      \ CharacterEscape[+U]
	      //      \ ClassSetReservedPunctuator
	      //      \ b

	      var res;
	      if (matchOne('b')) {
	        return createEscaped('singleEscape', 0x0008, '\\b');
	      } else if (matchOne('B')) {
	        bail('\\B not possible inside of ClassContents', '', pos - 2);
	      } else if (res = matchReg(/^[&\-!#%,:;<=>@`~]/)) {
	        return createEscaped('identifier', res[0].codePointAt(0), res[0]);
	      } else if (res = parseCharacterEscape()) {
	        return res;
	      } else {
	        return null;
	      }
	    }

	    function parseClassStringDisjunction() {
	      // ClassStringDisjunction ::
	      //      \q{ ClassStringDisjunctionContents }
	      //
	      // ClassStringDisjunctionContents ::
	      //      ClassString
	      //      ClassString | ClassStringDisjunctionContents
	      

	      // When calling this function, \q{ has already been consumed.
	      var from = pos - 3;

	      var res = [];
	      do {
	        res.push(parseClassString());
	      } while (matchOne('|'));

	      skip('}');

	      return createClassStrings(res, from, pos);
	    }

	    function parseClassString() {
	      // ClassString ::
	      //      [empty]
	      //      NonEmptyClassString
	      //
	      // NonEmptyClassString ::
	      //      ClassSetCharacter NonEmptyClassString?

	      var res = [], from = pos;
	      var char;

	      while (char = parseClassSetCharacter()) {
	        res.push(char);
	      }

	      return createClassString(res, from, pos);
	    }

	    function bail(message, details, from, to) {
	      from = from == null ? pos : from;
	      to = to == null ? from : to;

	      var contextStart = Math.max(0, from - 10);
	      var contextEnd = Math.min(to + 10, str.length);

	      // Output a bit of context and a line pointing to where our error is.
	      //
	      // We are assuming that there are no actual newlines in the content as this is a regular expression.
	      var context = '    ' + str.substring(contextStart, contextEnd);
	      var pointer = '    ' + new Array(from - contextStart + 1).join(' ') + '^';

	      throw SyntaxError(message + ' at position ' + from + (details ? ': ' + details : '') + '\n' + context + '\n' + pointer);
	    }

	    var backrefDenied = [];
	    var closedCaptureCounter = 0;
	    var firstIteration = true;
	    var shouldReparse = false;
	    var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;
	    var hasUnicodeSetFlag = (flags || "").indexOf("v") !== -1;
	    var isUnicodeMode = hasUnicodeFlag || hasUnicodeSetFlag;
	    var pos = 0;

	    if (hasUnicodeSetFlag && !features.unicodeSet) {
	      throw new Error('The "v" flag is only supported when the .unicodeSet option is enabled.');
	    }

	    if (hasUnicodeFlag && hasUnicodeSetFlag) {
	      throw new Error('The "u" and "v" flags are mutually exclusive.');
	    }

	    // Convert the input to a string and treat the empty string special.
	    str = String(str);
	    if (str === '') {
	      str = '(?:)';
	    }

	    var result = parseDisjunction();

	    if (result.range[1] !== str.length) {
	      bail('Could not parse entire input - got stuck', '', result.range[1]);
	    }

	    // The spec requires to interpret the `\2` in `/\2()()/` as backreference.
	    // As the parser collects the number of capture groups as the string is
	    // parsed it is impossible to make these decisions at the point when the
	    // `\2` is handled. In case the local decision turns out to be wrong after
	    // the parsing has finished, the input string is parsed a second time with
	    // the total number of capture groups set.
	    //
	    // SEE: https://github.com/jviereck/regjsparser/issues/70
	    shouldReparse = shouldReparse || backrefDenied.some(function (ref) {
	      return ref <= closedCaptureCounter;
	    });
	    if (shouldReparse) {
	      // Parse the input a second time.
	      pos = 0;
	      firstIteration = false;
	      return parseDisjunction();
	    }

	    return result;
	  }

	  var regjsparser = {
	    parse: parse
	  };

	  if (module.exports) {
	    module.exports = regjsparser;
	  } else {
	    window.regjsparser = regjsparser;
	  }

	}()); 
} (parser));

var parserExports = parser.exports;

function parse(pattern, unicode) {
    var ast = parserExports.parse(pattern, unicode ? 'u' : '', {
        lookbehind: true,
        unicodePropertyEscape: true,
    });
    return ast;
}

function last(input) {
    var length = input.length;
    return length ? input[length - 1] : null;
}
function dropCommon(a, b) {
    var commonLevels;
    for (commonLevels = 0; commonLevels < a.length &&
        commonLevels < b.length &&
        a[commonLevels] === b[commonLevels]; commonLevels++)
        ;
    return {
        a: a.slice(commonLevels),
        b: b.slice(commonLevels),
    };
}

var lookaheadBehaviours$1 = [
    'lookahead',
    'lookbehind',
    'negativeLookahead',
    'negativeLookbehind',
];
function replace(input, replacement, start, end) {
    return "".concat(input.slice(0, start)).concat(replacement).concat(input.slice(end));
}
function shiftOffsets(_a) {
    var after = _a.after, offsets = _a.offsets, shiftAmount = _a.shiftAmount;
    return new Set(__spreadArray([], __read(offsets), false).map(function (offset) {
        return offset > after ? offset + shiftAmount : offset;
    }));
}
function quantifierIterationsToString(quantifier) {
    if (quantifier.symbol) {
        return "".concat(quantifier.symbol).concat(quantifier.greedy ? '' : '?');
    }
    if (quantifier.min === quantifier.max) {
        return "{".concat(quantifier.min, "}");
    }
    return "{".concat(quantifier.min, ",").concat(quantifier.max || '', "}").concat(quantifier.greedy ? '' : '?');
}
function alreadyHasStartAnchorReplacement(node) {
    if (node.type !== 'alternative')
        return false;
    var body = node.body;
    /* istanbul ignore next */
    if (body.length < 1)
        return false;
    var _a = __read(body, 1), maybeQuantifier = _a[0];
    if (maybeQuantifier.type !== 'quantifier')
        return false;
    if (maybeQuantifier.min !== 0)
        return false;
    if (maybeQuantifier.max !== undefined)
        return false;
    if (maybeQuantifier.greedy)
        return false;
    var maybeCharacterClass = maybeQuantifier.body[0];
    if (maybeCharacterClass.type !== 'characterClass')
        return false;
    maybeCharacterClass.kind;
    if (maybeCharacterClass.body.length !== 0)
        return false;
    if (!maybeCharacterClass.negative)
        return false;
    return true;
}
function isMissingStartAnchor(rootNode) {
    if (alreadyHasStartAnchorReplacement(rootNode))
        return false;
    var check = function (node) {
        var e_1, _a;
        if (node.type === 'anchor') {
            if (node.kind === 'start')
                return 'anchor';
            return null;
        }
        if (node.type === 'quantifier' && node.max === 0)
            return null;
        if (node.type === 'alternative' ||
            node.type === 'group' ||
            node.type === 'quantifier') {
            var mayBeSkipped = node.type === 'quantifier' && node.min === 0;
            try {
                for (var _b = __values(node.body), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    var res = check(child);
                    if (res === 'consumingNode')
                        return 'consumingNode';
                    if (res === 'anchor') {
                        if (!mayBeSkipped)
                            return 'anchor';
                        return null;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return null;
        }
        if (node.type === 'disjunction') {
            var res = node.body.map(function (child) { return check(child); });
            if (res.some(function (a) { return a === 'consumingNode'; }))
                return 'consumingNode';
            if (res.every(function (a) { return a === 'anchor'; }))
                return 'anchor';
            return null;
        }
        return 'consumingNode';
    };
    return check(rootNode) === 'consumingNode';
}
function getRawWithoutCapturingGroupsOrLookaheads(rootNode) {
    var referencesWithOffset = new Map();
    var walk = function (node, offset) {
        var walkAll = function (nodes, startOffset) {
            var result = '';
            nodes.forEach(function (a) {
                result += walk(a, startOffset + result.length);
            });
            return result;
        };
        switch (node.type) {
            case 'anchor':
            case 'characterClass':
            case 'characterClassEscape':
            case 'unicodePropertyEscape':
            case 'value':
            case 'dot':
                return node.raw;
            case 'reference': {
                referencesWithOffset.set(node, offset);
                return node.raw;
            }
            case 'group': {
                switch (node.behavior) {
                    case 'normal':
                        return "(?:".concat(walkAll(node.body, offset + 3), ")");
                    case 'ignore':
                        return "(?:".concat(walkAll(node.body, offset + 3), ")");
                    case 'lookahead':
                    case 'lookbehind':
                    case 'negativeLookahead':
                    case 'negativeLookbehind':
                        return '';
                }
            }
            // eslint-disable-next-line no-fallthrough
            case 'disjunction': {
                var res_1 = '';
                node.body.forEach(function (a, i) {
                    if (i > 0)
                        res_1 += '|';
                    res_1 += walk(a, offset + res_1.length);
                });
                return res_1;
            }
            case 'alternative':
                return walkAll(node.body, offset);
            case 'quantifier': {
                return "".concat(walk(node.body[0], offset)).concat(quantifierIterationsToString(node));
            }
        }
    };
    var result = walk(rootNode, 0);
    return {
        referencesWithOffset: referencesWithOffset,
        result: result,
    };
}
/**
 * Downgrade the provided pattern if needed so that it is supported for checking.
 *
 * A downgraded pattern may introduce false positives.
 *
 * This does the following:
 * - If the pattern contains a reference to a group that lives in a positive lookahead,
 *   the reference will be replaced with a non-capturing group that contains referenced group.
 * - If the pattern contains a reference to a group that is a non-finite size,
 *   the reference will be replaced with a non-capturing group that contains the referenced group.
 * - If the pattern does not contain a start anchor then `[^]*` will be prepended, and the remainder
 *   wrapped in a none capturing group if needed.
 */
function downgradePattern(_a) {
    var pattern = _a.pattern, unicode = _a.unicode;
    var run = function (lastResult) {
        var ast = parse(lastResult.pattern, unicode);
        var actions = [];
        var needsStartAnchorReplacement = false;
        var needsWrappingInGroup = ast.type === 'disjunction';
        var groups = new Map();
        var infiniteGroups = new Set();
        var nextGroupIndex = 1;
        var lookaheadOnlyContainsGroup = function (lookahead, group) {
            if (lookahead.body.length !== 1)
                return false;
            var node = lookahead.body[0];
            return node === group;
        };
        var walkAll = function (_a) {
            var nodeStack = _a.nodeStack, nodes = _a.nodes, passedStartAnchor = _a.passedStartAnchor, serial = _a.serial;
            var justHadLookahead = null;
            nodes.forEach(function (expression) {
                if (serial) {
                    // eslint-disable-next-line no-use-before-define
                    walk({
                        immediatelyPrecedingLookahead: justHadLookahead,
                        node: expression,
                        nodeStack: nodeStack,
                        passedStartAnchor: passedStartAnchor,
                    });
                    justHadLookahead =
                        expression.type === 'group' && expression.behavior === 'lookahead'
                            ? expression
                            : null;
                }
                else {
                    // eslint-disable-next-line no-use-before-define
                    walk({
                        immediatelyPrecedingLookahead: justHadLookahead,
                        node: expression,
                        nodeStack: nodeStack,
                        passedStartAnchor: __assign({}, passedStartAnchor),
                    });
                }
            });
        };
        var walk = function (_a) {
            var immediatelyPrecedingLookahead = _a.immediatelyPrecedingLookahead, node = _a.node, nodeStack = _a.nodeStack, passedStartAnchor = _a.passedStartAnchor;
            var onConsumingNode = function () {
                if (!passedStartAnchor.value) {
                    needsStartAnchorReplacement = true;
                }
            };
            switch (node.type) {
                case 'characterClass':
                case 'characterClassEscape':
                case 'unicodePropertyEscape':
                case 'value':
                case 'dot':
                    onConsumingNode();
                    return;
                case 'anchor': {
                    if (node.kind === 'start') {
                        passedStartAnchor.value = true;
                    }
                    return;
                }
                case 'group': {
                    var groupIndex = null;
                    if (node.behavior === 'normal') {
                        groupIndex = nextGroupIndex;
                        nextGroupIndex++;
                    }
                    walkAll({
                        nodeStack: __spreadArray(__spreadArray([], __read(nodeStack), false), [node], false),
                        nodes: node.body,
                        passedStartAnchor: passedStartAnchor,
                        serial: true,
                    });
                    if (groupIndex !== null && node.behavior === 'normal') {
                        groups.set(groupIndex, { group: node, stack: __spreadArray([], __read(nodeStack), false) });
                    }
                    return;
                }
                case 'disjunction': {
                    walkAll({
                        nodeStack: __spreadArray(__spreadArray([], __read(nodeStack), false), [node], false),
                        nodes: node.body,
                        passedStartAnchor: passedStartAnchor,
                        serial: false,
                    });
                    return;
                }
                case 'alternative': {
                    walkAll({
                        nodeStack: __spreadArray(__spreadArray([], __read(nodeStack), false), [node], false),
                        nodes: node.body,
                        passedStartAnchor: passedStartAnchor,
                        serial: true,
                    });
                    return;
                }
                case 'quantifier': {
                    if (node.max !== 0) {
                        if (node.max === undefined) {
                            __spreadArray([], __read(nodeStack), false).reverse().some(function (stackNode) {
                                if (stackNode.type === 'group') {
                                    if (lookaheadBehaviours$1.indexOf(stackNode.behavior) >= 0) {
                                        // this infinite quantifier is contained in a lookahead,
                                        // so doesn't effect outer group size
                                        return true;
                                    }
                                    infiniteGroups.add(stackNode);
                                }
                                return false;
                            });
                        }
                        walkAll({
                            nodeStack: __spreadArray(__spreadArray([], __read(nodeStack), false), [node], false),
                            nodes: node.body,
                            passedStartAnchor: node.min === 0 ? __assign({}, passedStartAnchor) : passedStartAnchor,
                            serial: true,
                        });
                    }
                    return;
                }
                case 'reference': {
                    onConsumingNode();
                    var entry = groups.get(node.matchIndex);
                    if (entry) {
                        var group = entry.group, stack = entry.stack;
                        var localStack = dropCommon(stack, nodeStack).a;
                        var lookaheadStack = localStack.flatMap(function (stackNode) {
                            return stackNode.type === 'group' &&
                                lookaheadBehaviours$1.indexOf(stackNode.behavior) >= 0
                                ? [stackNode]
                                : [];
                        });
                        var groupMayNotBeReached = localStack.some(function (stackNode) {
                            return stackNode.type === 'disjunction' ||
                                (stackNode.type === 'quantifier' && stackNode.min === 0);
                        });
                        var groupInLookahead = lookaheadStack.length > 0;
                        var groupCouldBeSet = lookaheadStack.every(function (value) {
                            return value.behavior !== 'negativeLookahead' &&
                                value.behavior !== 'negativeLookbehind';
                        });
                        if (groupCouldBeSet &&
                            (groupInLookahead || infiniteGroups.has(group))) {
                            // if we have something like `a(?=(bc))\1`
                            // `\1`, and therefore the group we inline in its place, can be considered atomic
                            // given that lookaheads can't be backtracked into and immediately after the
                            // lookahead we match the same that was in the lookahead
                            var atomic = !!immediatelyPrecedingLookahead &&
                                lookaheadOnlyContainsGroup(immediatelyPrecedingLookahead, group);
                            var optional = groupInLookahead && groupMayNotBeReached;
                            actions.push({
                                atomicOrOptional: atomic
                                    ? 'atomic'
                                    : optional
                                        ? 'optional'
                                        : null,
                                group: group,
                                reference: node,
                            });
                        }
                    }
                    return;
                }
            }
        };
        walk({
            immediatelyPrecedingLookahead: null,
            node: ast,
            nodeStack: [],
            passedStartAnchor: { value: false },
        });
        var newPattern = lastResult.pattern;
        var atomicGroupOffsets = new Set(lastResult.atomicGroupOffsets);
        var needToRerun = false;
        __spreadArray([], __read(actions), false).sort(function (a, b) { return b.reference.range[0] - a.reference.range[0]; })
            .forEach(function (action) {
            var atomicOrOptional = action.atomicOrOptional, group = action.group, _a = __read(action.reference.range, 2), referenceStart = _a[0], referenceEnd = _a[1];
            var _b = getRawWithoutCapturingGroupsOrLookaheads(group), result = _b.result, referencesWithOffset = _b.referencesWithOffset;
            if (referencesWithOffset.size > 0) {
                needToRerun = true;
            }
            var replacement = atomicOrOptional === 'optional' ? "(?:".concat(result, "?)") : result;
            newPattern = replace(newPattern, replacement, referenceStart, referenceEnd);
            var shiftAmount = replacement.length - (referenceEnd - referenceStart);
            atomicGroupOffsets = shiftOffsets({
                after: referenceStart,
                offsets: atomicGroupOffsets,
                shiftAmount: shiftAmount,
            });
            if (atomicOrOptional === 'atomic') {
                atomicGroupOffsets.add(referenceStart);
            }
            actions.forEach(function (_a) {
                var innerAtomicOrOptional = _a.atomicOrOptional, innerReference = _a.reference;
                if (innerAtomicOrOptional === 'atomic') {
                    var offset = referencesWithOffset.get(innerReference);
                    if (offset !== undefined) {
                        atomicGroupOffsets.add(referenceStart + offset);
                    }
                }
            });
        });
        if (needsStartAnchorReplacement && !alreadyHasStartAnchorReplacement(ast)) {
            if (needsWrappingInGroup) {
                newPattern = "(?:".concat(newPattern, ")");
            }
            newPattern = "[^]*?".concat(newPattern);
            atomicGroupOffsets = shiftOffsets({
                after: -1,
                offsets: atomicGroupOffsets,
                shiftAmount: needsWrappingInGroup ? 8 : 5,
            });
        }
        return { needToRerun: needToRerun, result: { atomicGroupOffsets: atomicGroupOffsets, pattern: newPattern } };
    };
    var lastResult = {
        atomicGroupOffsets: new Set(),
        pattern: pattern,
    };
    for (;;) {
        var _b = run(lastResult), result = _b.result, needToRerun = _b.needToRerun;
        lastResult = result;
        if (!needToRerun) {
            break;
        }
    }
    return lastResult;
}

var _version = "6.1.2";

// here so that can be mocked out for testing
function buildFinalizationRegistry(cleanupCallback) {
    return new FinalizationRegistry(cleanupCallback);
}

var forkSymbol = Symbol('fork');
var pendingResultsSymbol = Symbol('pendingResults');
function buildForkableIterator(source) {
    var onResult = new Set();
    var registry = buildFinalizationRegistry(function (onResultCallback) {
        onResult.delete(onResultCallback);
    });
    var readSource = function () {
        var result = source.next();
        onResult.forEach(function (fn) { return fn(result); });
    };
    var makeFork = function (initialPendingResults) {
        var _a;
        var iterator = (_a = {},
            _a[forkSymbol] = function () {
                return makeFork(this[pendingResultsSymbol]);
            },
            _a[pendingResultsSymbol] = initialPendingResults.slice(0),
            _a.next = function (value) {
                if (value !== undefined) {
                    throw new Error('`ForkableIterator` `next()` cannot take a value');
                }
                var pendingResults = this[pendingResultsSymbol];
                if (!pendingResults.length) {
                    readSource();
                }
                return pendingResults.shift();
            },
            _a);
        var ref = new WeakRef(iterator);
        var callback = function (result) {
            var maybeIterator = ref.deref();
            /* istanbul ignore next */
            maybeIterator === null || maybeIterator === void 0 ? void 0 : maybeIterator[pendingResultsSymbol].push(result);
        };
        registry.register(iterator, callback);
        onResult.add(callback);
        return iterator;
    };
    return makeFork([]);
}
/**
 * Create a fork of the provided `ForkableIterator`/`ForkableAsyncIterator` at the current point.
 */
function fork(forkableIterator) {
    if (!forkableIterator || !forkableIterator[forkSymbol]) {
        throw new Error('The provided value was not a `ForkableIterator` from `buildForkableIterator()`');
    }
    return forkableIterator[forkSymbol]();
}

// eslint-disable-next-line @typescript-eslint/no-empty-function
function emptyReader() { return __generator(this, function (_a) {
    return [2 /*return*/];
}); }
/**
 * Returns a reader that can be forked with the `fork` function.
 *
 * The source reader must not be read from directly.
 */
function buildForkableReader(sourceReader) {
    return buildForkableIterator(sourceReader);
}
/**
 * Chains an array of readers together that run consecutively.
 */
function chainReaders(readers) {
    var readers_1, readers_1_1, reader, next, e_1_1;
    var e_1, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _b.trys.push([0, 6, 7, 8]);
                readers_1 = __values(readers), readers_1_1 = readers_1.next();
                _b.label = 1;
            case 1:
                if (!!readers_1_1.done) return [3 /*break*/, 5];
                reader = readers_1_1.value;
                next = void 0;
                _b.label = 2;
            case 2:
                if (!!(next = reader.next()).done) return [3 /*break*/, 4];
                return [4 /*yield*/, next.value];
            case 3:
                _b.sent();
                return [3 /*break*/, 2];
            case 4:
                readers_1_1 = readers_1.next();
                return [3 /*break*/, 1];
            case 5: return [3 /*break*/, 8];
            case 6:
                e_1_1 = _b.sent();
                e_1 = { error: e_1_1 };
                return [3 /*break*/, 8];
            case 7:
                try {
                    if (readers_1_1 && !readers_1_1.done && (_a = readers_1.return)) _a.call(readers_1);
                }
                finally { if (e_1) throw e_1.error; }
                return [7 /*endfinally*/];
            case 8: return [2 /*return*/];
        }
    });
}
/**
 * Builds a reader that yields each item in the input array.
 */
function buildArrayReader(input) {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [5 /*yield**/, __values(input)];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}

function subtractRanges(source, toSubtract) {
    var res = [];
    if (source[0] < toSubtract[0]) {
        res.push([source[0], Math.min(toSubtract[0] - 1, source[1])]);
    }
    if (source[1] > toSubtract[1]) {
        res.push([Math.max(toSubtract[1] + 1, source[0]), source[1]]);
    }
    return res;
}
function intersectRanges(a, b) {
    var startShared = Math.max(a[0], b[0]);
    var endShared = Math.min(a[1], b[1]);
    if (startShared > endShared) {
        return null;
    }
    return [startShared, endShared];
}
function createRanges(set) {
    var ascending = __spreadArray([], __read(set), false).sort(function (a, b) { return a - b; });
    var ranges = [];
    var startIndex = 0;
    for (var i = 0; i < ascending.length; i++) {
        var startValue = ascending[startIndex];
        var currentValue = ascending[i];
        var nextValue = i + 1 < ascending.length ? ascending[i + 1] : null;
        if (nextValue === null || nextValue - startValue !== i - startIndex + 1) {
            ranges.push([startValue, currentValue]);
            startIndex = i + 1;
        }
    }
    return ranges;
}
/* note input ranges must be sorted and not overlap */
function invertRanges(ranges) {
    var result = [];
    for (var i = 0; i < ranges.length + 1; i++) {
        var prev = i - 1 >= 0 ? ranges[i - 1] : null;
        var current = i < ranges.length ? ranges[i] : null;
        var start = prev ? prev[1] + 1 : -Infinity;
        var end = current ? current[0] - 1 : +Infinity;
        if (start - end === 1)
            continue;
        if (start > end)
            throw new Error('Internal error: invalid ranges input');
        result.push([start, end]);
    }
    return result;
}

/**
 * Returns `true` if the provided `CharacterGroups` definitely matches no characters.
 */
function isEmptyCharacterGroups(group) {
    return (!group.rangesNegated &&
        !group.ranges.length &&
        !group.unicodePropertyEscapes.size);
}
function intersectCharacterGroups(a, b) {
    var e_1, _a;
    var _b, _c;
    var newRanges;
    var newNegated;
    if (!a.rangesNegated) {
        if (!b.rangesNegated) {
            newNegated = false;
            newRanges = [];
            a.ranges.forEach(function (aRange) {
                b.ranges.forEach(function (bRange) {
                    var intersection = intersectRanges(aRange, bRange);
                    if (intersection)
                        newRanges.push(intersection);
                });
            });
        }
        else {
            newNegated = false;
            newRanges = __spreadArray([], __read(a.ranges), false);
            b.ranges.forEach(function (bRange) {
                var narrowed = [];
                newRanges.forEach(function (aRange) {
                    narrowed.push.apply(narrowed, __spreadArray([], __read(subtractRanges(aRange, bRange)), false));
                });
                newRanges = narrowed;
            });
        }
    }
    else {
        if (!b.rangesNegated) {
            newNegated = false;
            newRanges = __spreadArray([], __read(b.ranges), false);
            a.ranges.forEach(function (aRange) {
                var narrowed = [];
                newRanges.forEach(function (bRange) {
                    narrowed.push.apply(narrowed, __spreadArray([], __read(subtractRanges(bRange, aRange)), false));
                });
                newRanges = narrowed;
            });
        }
        else {
            newNegated = true;
            newRanges = __spreadArray(__spreadArray([], __read(a.ranges), false), __read(b.ranges), false);
        }
    }
    var allUnicodePropertyEscapes = new Set(__spreadArray(__spreadArray([], __read(a.unicodePropertyEscapes.keys()), false), __read(b.unicodePropertyEscapes.keys()), false));
    var newUnicodePropertyEscapes = new Map();
    try {
        for (var allUnicodePropertyEscapes_1 = __values(allUnicodePropertyEscapes), allUnicodePropertyEscapes_1_1 = allUnicodePropertyEscapes_1.next(); !allUnicodePropertyEscapes_1_1.done; allUnicodePropertyEscapes_1_1 = allUnicodePropertyEscapes_1.next()) {
            var unicodePropertyEscape = allUnicodePropertyEscapes_1_1.value;
            var aEscape = (_b = a.unicodePropertyEscapes.get(unicodePropertyEscape)) !== null && _b !== void 0 ? _b : null;
            var bEscape = (_c = b.unicodePropertyEscapes.get(unicodePropertyEscape)) !== null && _c !== void 0 ? _c : null;
            // assume that all characters that match an escape (or inverse of escape) remain, unless
            // they are intersected with the negative
            // `isEmptyCharacterGroups` will never be `true` whilst there is an escape
            if (aEscape !== null && bEscape === null) {
                newUnicodePropertyEscapes.set(unicodePropertyEscape, aEscape);
            }
            else if (aEscape === null && bEscape !== null) {
                newUnicodePropertyEscapes.set(unicodePropertyEscape, bEscape);
            }
            else if (aEscape !== null && bEscape !== null && aEscape === bEscape) {
                newUnicodePropertyEscapes.set(unicodePropertyEscape, aEscape);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (allUnicodePropertyEscapes_1_1 && !allUnicodePropertyEscapes_1_1.done && (_a = allUnicodePropertyEscapes_1.return)) _a.call(allUnicodePropertyEscapes_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return {
        ranges: newRanges,
        rangesNegated: newNegated,
        unicodePropertyEscapes: newUnicodePropertyEscapes,
    };
}

function buildEndReader(offset) {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, {
                    bounded: false,
                    offset: offset,
                    stack: [],
                    subType: 'end',
                    type: characterReaderTypeCharacterEntry,
                }];
            case 1:
                _a.sent();
                /* istanbul ignore next */
                throw new Error('Internal error: should not be reading after end');
        }
    });
}

/**
 * Join multiple `CharacterReader`'s together.
 *
 * It has understanding of the `split` type.
 *
 * `getAction` should return
 * - `continue`: This results in `getReader` being called with the next index
 *   and a new `CharacterReader` should be returned
 * - `fork`: This results in the reader splitting, with the split reader being empty,
 *   and then `getReader` is called with the next index and a new `CharacterReader`
 *   should be returned
 * - `stop`: This means the reader will end
 */
function join(getAction, getReader) {
    var _join = function (_getAction, _getReader, timeSinceEmitSomething) {
        var i, action, emittedSomething, reader, next, _loop_1;
        if (timeSinceEmitSomething === void 0) { timeSinceEmitSomething = 0; }
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    i = 0;
                    _a.label = 1;
                case 1:
                    action = _getAction(i, timeSinceEmitSomething);
                    if (!(action === 'stop')) return [3 /*break*/, 2];
                    return [2 /*return*/];
                case 2:
                    if (!(action === 'fork')) return [3 /*break*/, 4];
                    return [4 /*yield*/, {
                            reader: function () { return emptyReader(); },
                            subType: null,
                            type: characterReaderTypeSplit,
                        }];
                case 3:
                    _a.sent();
                    _a.label = 4;
                case 4:
                    emittedSomething = false;
                    reader = _getReader(i);
                    next = void 0;
                    _loop_1 = function () {
                        var value, _b, _i_1, _timeSinceEmittedSomething_1;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    value = next.value;
                                    _b = value.type;
                                    switch (_b) {
                                        case characterReaderTypeSplit: return [3 /*break*/, 1];
                                        case characterReaderTypeCharacterEntry: return [3 /*break*/, 3];
                                    }
                                    return [3 /*break*/, 5];
                                case 1:
                                    _i_1 = i;
                                    _timeSinceEmittedSomething_1 = timeSinceEmitSomething;
                                    return [4 /*yield*/, {
                                            reader: function () {
                                                return _join(function (innerIndex, innerTimeSinceEmittedSomething) {
                                                    return innerIndex === 0
                                                        ? 'continue'
                                                        : _getAction(innerIndex + _i_1, innerTimeSinceEmittedSomething);
                                                }, function (innerIndex) {
                                                    return innerIndex === 0
                                                        ? value.reader()
                                                        : _getReader(innerIndex + _i_1);
                                                }, _timeSinceEmittedSomething_1);
                                            },
                                            subType: value.subType,
                                            type: characterReaderTypeSplit,
                                        }];
                                case 2:
                                    _c.sent();
                                    return [3 /*break*/, 5];
                                case 3:
                                    if (value.subType !== 'null' &&
                                        value.subType !== 'start' &&
                                        value.subType !== 'end') {
                                        emittedSomething = true;
                                    }
                                    return [4 /*yield*/, value];
                                case 4:
                                    _c.sent();
                                    return [3 /*break*/, 5];
                                case 5: return [2 /*return*/];
                            }
                        });
                    };
                    _a.label = 5;
                case 5:
                    if (!!(next = reader.next()).done) return [3 /*break*/, 7];
                    return [5 /*yield**/, _loop_1()];
                case 6:
                    _a.sent();
                    return [3 /*break*/, 5];
                case 7:
                    timeSinceEmitSomething = emittedSomething
                        ? 0
                        : timeSinceEmitSomething + 1;
                    _a.label = 8;
                case 8:
                    i++;
                    return [3 /*break*/, 1];
                case 9: return [2 /*return*/];
            }
        });
    };
    return _join(getAction, getReader);
}
/**
 * Joins an array of `CharacterReader`'s together, with  understanding
 * of the `split` type. If a reader splits, when the split reader ends,
 * the next `CharacterReader` in the array will follow.
 */
function joinArray(input) {
    var length = input.length;
    return join(function (i) { return (i < length ? 'continue' : 'stop'); }, function (i) { return input[i](); });
}

function buildSequenceCharacterReader(_a) {
    var caseInsensitive = _a.caseInsensitive, dotAll = _a.dotAll, nodes = _a.nodes;
    return joinArray(nodes.map(function (node) {
        return function () {
            return buildCharacterReader({ caseInsensitive: caseInsensitive, dotAll: dotAll, node: node });
        };
    }));
}

/**
 * Maps each value of a `CharacterReader` from one value to another.
 *
 * It handles the `split` type internally.
 */
function map(reader, handle) {
    var startThread = function (innerReader) {
        var next, _loop_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _loop_1 = function () {
                        var value, _b;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    value = next.value;
                                    _b = value.type;
                                    switch (_b) {
                                        case characterReaderTypeSplit: return [3 /*break*/, 1];
                                        case characterReaderTypeCharacterEntry: return [3 /*break*/, 3];
                                    }
                                    return [3 /*break*/, 5];
                                case 1: return [4 /*yield*/, {
                                        reader: function () { return startThread(value.reader()); },
                                        subType: value.subType,
                                        type: characterReaderTypeSplit,
                                    }];
                                case 2:
                                    _c.sent();
                                    return [3 /*break*/, 5];
                                case 3: return [4 /*yield*/, handle(value)];
                                case 4:
                                    _c.sent();
                                    return [3 /*break*/, 5];
                                case 5: return [2 /*return*/];
                            }
                        });
                    };
                    _a.label = 1;
                case 1:
                    if (!!(next = innerReader.next()).done) return [3 /*break*/, 3];
                    return [5 /*yield**/, _loop_1()];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 1];
                case 3: return [2 /*return*/];
            }
        });
    };
    return startThread(reader);
}

function getGroups(stack) {
    return new Set(stack.flatMap(function (entry) { return (entry.type === 'group' ? [entry.group] : []); }));
}
function getLookaheadStack(stack) {
    var e_1, _a;
    var lookaheadStack = [];
    try {
        for (var stack_1 = __values(stack), stack_1_1 = stack_1.next(); !stack_1_1.done; stack_1_1 = stack_1.next()) {
            var entry = stack_1_1.value;
            if (entry.type === 'group') {
                var group = entry.group;
                var behavior = group.behavior;
                if (behavior === 'lookbehind' ||
                    behavior === 'negativeLookbehind' ||
                    behavior === 'negativeLookahead' ||
                    behavior === 'lookahead') {
                    lookaheadStack.push(group);
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (stack_1_1 && !stack_1_1.done && (_a = stack_1.return)) _a.call(stack_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return lookaheadStack;
}
function buildGroupCharacterReader(_a) {
    var caseInsensitive = _a.caseInsensitive, dotAll = _a.dotAll, node = _a.node;
    switch (node.behavior) {
        case 'lookbehind':
        case 'negativeLookbehind':
        case 'lookahead':
        case 'negativeLookahead': {
            return buildArrayReader([
                {
                    reader: function () {
                        return joinArray([
                            function () {
                                return map(buildSequenceCharacterReader({
                                    caseInsensitive: caseInsensitive,
                                    dotAll: dotAll,
                                    nodes: node.body,
                                }), function (value) {
                                    return __assign(__assign({}, value), { stack: __spreadArray([{ group: node, type: 'group' }], __read(value.stack), false) });
                                });
                            },
                            function () { return buildEndReader(node.range[1]); },
                        ]);
                    },
                    subType: node.behavior,
                    type: characterReaderTypeSplit,
                },
            ]);
        }
        case 'ignore':
        case 'normal': {
            return map(buildSequenceCharacterReader({
                caseInsensitive: caseInsensitive,
                dotAll: dotAll,
                nodes: node.body,
            }), function (value) {
                return __assign(__assign({}, value), { stack: __spreadArray([{ group: node, type: 'group' }], __read(value.stack), false) });
            });
        }
    }
}

function buildNullCharacterReader(offset) {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, {
                    offset: offset,
                    stack: [],
                    subType: 'null',
                    type: characterReaderTypeCharacterEntry,
                }];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}

function mustGet(map, key) {
    if (!map.has(key)) {
        throw new Error('Internal error: map missing key');
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return map.get(key);
}

function buildQuantifiersInInfinitePortion(stack, nodeExtra) {
    var exhaustive = stack.some(function (entry) {
        if (entry.type !== 'group' || entry.group.behavior !== 'normal') {
            return false;
        }
        var index = mustGet(nodeExtra.capturingGroupToIndex, entry.group);
        var hasReference = nodeExtra.reachableReferences.some(function (reference) { return reference.matchIndex === index; });
        return hasReference;
    });
    // if we are part of a group that is referenced then we need to include all iterations
    // because that could have an effect later where the reference is
    if (exhaustive)
        return new Set();
    return new Set(stack
        .flatMap(function (entry) { return (entry.type === 'quantifier' ? [entry] : []); })
        .filter(function (_a) {
        var iteration = _a.iteration, quantifier = _a.quantifier;
        return iteration >= 1 && iteration >= quantifier.min;
    })
        .map(function (_a) {
        var quantifier = _a.quantifier;
        return quantifier;
    }));
}
function buildQuantifierIterations(stack) {
    var res = new Map();
    stack
        .flatMap(function (entry) { return (entry.type === 'quantifier' ? [entry] : []); })
        .forEach(function (_a) {
        var iteration = _a.iteration, quantifier = _a.quantifier;
        return res.set(quantifier, iteration);
    });
    return res;
}
function buildQuantifierCharacterReader(_a) {
    var caseInsensitive = _a.caseInsensitive, dotAll = _a.dotAll, node = _a.node;
    var min = node.min, _b = node.max, max = _b === void 0 ? Infinity : _b;
    return joinArray([
        // always emit the null first so that we always emit something in cases where the loop is empty
        function () { return buildNullCharacterReader(node.body[0].range[0]); },
        function () {
            return join(function (i, timeSinceEmit) {
                // prevent infinite loop on something like `()*`
                // > 1 so that the capturing groups are cleared with something like `(?:(a)|)*`
                if (timeSinceEmit > 1)
                    return 'stop';
                if (i >= max)
                    return 'stop';
                if (i >= min)
                    return 'fork';
                return 'continue';
            }, function (i) {
                return map(joinArray(__spreadArray(__spreadArray([], __read((i > 0
                    ? [
                        function () {
                            return buildNullCharacterReader(node.body[0].range[0]);
                        },
                    ]
                    : [])), false), [
                    function () {
                        return buildCharacterReader({
                            caseInsensitive: caseInsensitive,
                            dotAll: dotAll,
                            node: node.body[0],
                        });
                    },
                ], false)), function (value) {
                    return __assign(__assign({}, value), { stack: __spreadArray([
                            {
                                iteration: i,
                                quantifier: node,
                                type: 'quantifier',
                            }
                        ], __read(value.stack), false) });
                });
            });
        },
    ]);
}

function buildAnchorReader(node) {
    var _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _a = node.kind;
                switch (_a) {
                    case 'end': return [3 /*break*/, 1];
                    case 'start': return [3 /*break*/, 3];
                    case 'boundary': return [3 /*break*/, 5];
                    case 'not-boundary': return [3 /*break*/, 5];
                }
                return [3 /*break*/, 6];
            case 1: return [4 /*yield*/, {
                    bounded: true,
                    offset: node.range[0],
                    stack: [],
                    subType: 'end',
                    type: characterReaderTypeCharacterEntry,
                }];
            case 2:
                _b.sent();
                /* istanbul ignore next */
                throw new Error('Internal error: should not be reading after end');
            case 3: return [4 /*yield*/, {
                    offset: node.range[0],
                    stack: [],
                    subType: 'start',
                    type: characterReaderTypeCharacterEntry,
                }];
            case 4:
                _b.sent();
                return [3 /*break*/, 6];
            case 5:
                {
                    return [3 /*break*/, 6];
                }
            case 6: return [2 /*return*/];
        }
    });
}

// [0-9]
var dRanges = [[48, 57]];
var inverseDRanges = invertRanges(dRanges);
// [A-Za-z0-9_]
var wRanges = [
    [48, 57],
    [65, 90],
    [95, 95],
    [97, 122],
];
var inverseWRanges = invertRanges(wRanges);
// [\f\n\r\t\v\u0020\u00a0\u1680\u2000-\u200a\u2028-\u2029\u202f\u205f\u3000\ufeff]
var sRanges = [
    [9, 9],
    [10, 10],
    [11, 11],
    [12, 12],
    [13, 13],
    [32, 32],
    [160, 160],
    [5760, 5760],
    [8192, 8202],
    [8232, 8233],
    [8239, 8239],
    [8287, 8287],
    [12288, 12288],
    [65279, 65279],
];
var inverseSRanges = invertRanges(sRanges);
function characterClassEscapeToRange(value) {
    switch (value) {
        case 'd':
        case 'D': {
            return value === 'd' ? dRanges : inverseDRanges;
        }
        case 'w':
        case 'W': {
            return value === 'w' ? wRanges : inverseWRanges;
        }
        case 's':
        case 'S': {
            return value === 's' ? sRanges : inverseSRanges;
        }
    }
}
function buildCharacterClassEscapeReader(node) {
    var value, ranges;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                value = node.value;
                ranges = characterClassEscapeToRange(value);
                return [4 /*yield*/, {
                        characterGroups: {
                            ranges: ranges,
                            rangesNegated: false,
                            unicodePropertyEscapes: new Map(),
                        },
                        node: node,
                        stack: [],
                        subType: 'groups',
                        type: characterReaderTypeCharacterEntry,
                    }];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}

function toCodePoint(input) {
    // https://tc39.es/ecma262/multipage/text-processing.html#sec-runtime-semantics-canonicalize-ch
    // step 7
    if (input.length > 1)
        return null;
    var codePoint = input.codePointAt(0);
    /* istanbul ignore next */
    if (!codePoint)
        throw new Error('Internal error: expected codepoint');
    return codePoint;
}
function toUpperCaseCodePoint(codePoint) {
    var upperCase = String.fromCodePoint(codePoint).toUpperCase();
    var upperCodePoint = toCodePoint(upperCase);
    return upperCodePoint !== null ? upperCodePoint : codePoint;
}
function buildCodePointRanges(_a) {
    var caseInsensitive = _a.caseInsensitive, highCodePoint = _a.highCodePoint, lowCodePoint = _a.lowCodePoint;
    if (!caseInsensitive) {
        return [[lowCodePoint, highCodePoint]];
    }
    var codePoints = new Set();
    for (var codePoint = lowCodePoint; codePoint <= highCodePoint; codePoint++) {
        codePoints.add(toUpperCaseCodePoint(codePoint));
    }
    return createRanges(codePoints);
}

function codePointFromValue(_a) {
    var caseInsensitive = _a.caseInsensitive, value = _a.value;
    var codePoint = value.codePoint;
    return caseInsensitive ? toUpperCaseCodePoint(codePoint) : codePoint;
}
function buildValueCharacterReader(_a) {
    var caseInsensitive = _a.caseInsensitive, node = _a.node;
    var codePoint = codePointFromValue({ caseInsensitive: caseInsensitive, value: node });
    return buildArrayReader([
        {
            characterGroups: {
                ranges: [[codePoint, codePoint]],
                rangesNegated: false,
                unicodePropertyEscapes: new Map(),
            },
            node: node,
            stack: [],
            subType: 'groups',
            type: characterReaderTypeCharacterEntry,
        },
    ]);
}

function buildCharacterClassCharacterReader(_a) {
    var e_1, _b;
    var caseInsensitive = _a.caseInsensitive, node = _a.node;
    var ranges = [];
    var unicodePropertyEscapes = new Map();
    var matchesEverything = false;
    try {
        outer: for (var _c = __values(node.body), _d = _c.next(); !_d.done; _d = _c.next()) {
            var expression = _d.value;
            switch (expression.type) {
                case 'value': {
                    var codePoint = codePointFromValue({
                        caseInsensitive: caseInsensitive,
                        value: expression,
                    });
                    ranges.push([codePoint, codePoint]);
                    break;
                }
                case 'characterClassRange': {
                    ranges.push.apply(ranges, __spreadArray([], __read(buildCodePointRanges({
                        caseInsensitive: caseInsensitive,
                        highCodePoint: expression.max.codePoint,
                        lowCodePoint: expression.min.codePoint,
                    })), false));
                    break;
                }
                case 'characterClassEscape': {
                    var value = expression.value;
                    ranges.push.apply(ranges, __spreadArray([], __read(characterClassEscapeToRange(value)), false));
                    break;
                }
                case 'unicodePropertyEscape': {
                    var resolvedNegative = expression.negative !== node.negative;
                    if (unicodePropertyEscapes.get(expression.value) === !resolvedNegative) {
                        matchesEverything = true;
                        break outer;
                    }
                    unicodePropertyEscapes.set(expression.value, resolvedNegative);
                    break;
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return buildArrayReader([
        {
            characterGroups: matchesEverything
                ? { ranges: [], rangesNegated: true, unicodePropertyEscapes: new Map() }
                : {
                    ranges: ranges,
                    rangesNegated: node.negative,
                    unicodePropertyEscapes: unicodePropertyEscapes,
                },
            node: node,
            stack: [],
            subType: 'groups',
            type: characterReaderTypeCharacterEntry,
        },
    ]);
}

function buildDisjunctionCharacterReader(_a) {
    var caseInsensitive = _a.caseInsensitive, dotAll = _a.dotAll, node = _a.node;
    return chainReaders([
        buildArrayReader(node.body.slice(0, -1).map(function (part) {
            return {
                reader: function () {
                    return buildCharacterReader({ caseInsensitive: caseInsensitive, dotAll: dotAll, node: part });
                },
                subType: null,
                type: characterReaderTypeSplit,
            };
        })),
        buildCharacterReader({
            caseInsensitive: caseInsensitive,
            dotAll: dotAll,
            node: node.body[node.body.length - 1],
        }),
    ]);
}

function buildDotCharacterReader(_a) {
    var dotAll = _a.dotAll, node = _a.node;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, {
                    characterGroups: {
                        ranges: dotAll
                            ? []
                            : // [\n\r\u2028-\u2029]
                                [
                                    [10, 10],
                                    [13, 13],
                                    [8232, 8233],
                                ],
                        rangesNegated: true,
                        unicodePropertyEscapes: new Map(),
                    },
                    node: node,
                    stack: [],
                    subType: 'groups',
                    type: characterReaderTypeCharacterEntry,
                }];
            case 1:
                _b.sent();
                return [2 /*return*/];
        }
    });
}

function buildReferenceCharacterReader(node) {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, {
                    node: node,
                    referenceIndex: node.matchIndex,
                    stack: [],
                    subType: 'reference',
                    type: characterReaderTypeCharacterEntry,
                }];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}

function buildUnicodePropertyEscapeCharacterReader(node) {
    return buildArrayReader([
        {
            characterGroups: {
                ranges: [],
                rangesNegated: false,
                unicodePropertyEscapes: new Map([[node.value, node.negative]]),
            },
            node: node,
            stack: [],
            subType: 'groups',
            type: characterReaderTypeCharacterEntry,
        },
    ]);
}

var characterReaderTypeCharacterEntry = Symbol('characterReaderTypeCharacterEntry');
var characterReaderTypeSplit = Symbol('characterReaderTypeSplit');
function buildCharacterReader(_a) {
    var caseInsensitive = _a.caseInsensitive, dotAll = _a.dotAll, node = _a.node;
    switch (node.type) {
        case 'anchor':
            return buildAnchorReader(node);
        case 'characterClass':
            return buildCharacterClassCharacterReader({ caseInsensitive: caseInsensitive, node: node });
        case 'characterClassEscape':
            return buildCharacterClassEscapeReader(node);
        case 'unicodePropertyEscape':
            return buildUnicodePropertyEscapeCharacterReader(node);
        case 'reference':
            return buildReferenceCharacterReader(node);
        case 'value':
            return buildValueCharacterReader({ caseInsensitive: caseInsensitive, node: node });
        case 'dot':
            return buildDotCharacterReader({ dotAll: dotAll, node: node });
        case 'alternative':
            return buildSequenceCharacterReader({
                caseInsensitive: caseInsensitive,
                dotAll: dotAll,
                nodes: node.body,
            });
        case 'disjunction':
            return buildDisjunctionCharacterReader({ caseInsensitive: caseInsensitive, dotAll: dotAll, node: node });
        case 'group':
            return buildGroupCharacterReader({ caseInsensitive: caseInsensitive, dotAll: dotAll, node: node });
        case 'quantifier':
            return buildQuantifierCharacterReader({ caseInsensitive: caseInsensitive, dotAll: dotAll, node: node });
    }
}

var characterReaderLevel1TypeSplit = Symbol('characterReaderLevel2TypeSplit');
var characterReaderLevel1TypeEntry = Symbol('characterReaderLevel1TypeEntry');
/**
 * Returns a `CharacterReaderLevel1` which builds on top of
 * `CharacterReaderLevel0` adds a `precedingZeroWidthEntries` property
 * and makes every result map to a character.
 */
function buildCharacterReaderLevel1(_a) {
    var caseInsensitive = _a.caseInsensitive, dotAll = _a.dotAll, node = _a.node;
    var startThread = function (reader, precedingZeroWidthEntries) {
        var next, _loop_1, state_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _loop_1 = function () {
                        var _b, _c, value_1, _precedingZeroWidthEntries_1;
                        return __generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    _b = next.value.type;
                                    switch (_b) {
                                        case characterReaderTypeCharacterEntry: return [3 /*break*/, 1];
                                        case characterReaderTypeSplit: return [3 /*break*/, 10];
                                    }
                                    return [3 /*break*/, 12];
                                case 1:
                                    _c = next.value.subType;
                                    switch (_c) {
                                        case 'groups': return [3 /*break*/, 2];
                                        case 'reference': return [3 /*break*/, 4];
                                        case 'end': return [3 /*break*/, 6];
                                        case 'null': return [3 /*break*/, 7];
                                        case 'start': return [3 /*break*/, 8];
                                    }
                                    return [3 /*break*/, 9];
                                case 2: return [4 /*yield*/, {
                                        characterGroups: next.value.characterGroups,
                                        node: next.value.node,
                                        precedingZeroWidthEntries: precedingZeroWidthEntries,
                                        stack: next.value.stack,
                                        subType: 'groups',
                                        type: characterReaderLevel1TypeEntry,
                                    }];
                                case 3:
                                    _d.sent();
                                    precedingZeroWidthEntries = [];
                                    return [3 /*break*/, 9];
                                case 4: return [4 /*yield*/, {
                                        node: next.value.node,
                                        precedingZeroWidthEntries: precedingZeroWidthEntries,
                                        referenceIndex: next.value.referenceIndex,
                                        stack: next.value.stack,
                                        subType: next.value.subType,
                                        type: characterReaderLevel1TypeEntry,
                                    }];
                                case 5:
                                    _d.sent();
                                    precedingZeroWidthEntries = [];
                                    return [3 /*break*/, 9];
                                case 6:
                                    {
                                        return [2 /*return*/, { value: {
                                                    bounded: next.value.bounded,
                                                    precedingZeroWidthEntries: precedingZeroWidthEntries,
                                                } }];
                                    }
                                case 7:
                                    {
                                        precedingZeroWidthEntries = __spreadArray(__spreadArray([], __read(precedingZeroWidthEntries), false), [
                                            { offset: next.value.offset, type: 'null' },
                                        ], false);
                                        return [3 /*break*/, 9];
                                    }
                                case 8:
                                    {
                                        precedingZeroWidthEntries = __spreadArray(__spreadArray([], __read(precedingZeroWidthEntries), false), [
                                            { offset: next.value.offset, type: 'start' },
                                        ], false);
                                        return [3 /*break*/, 9];
                                    }
                                case 9: return [3 /*break*/, 12];
                                case 10:
                                    value_1 = next.value;
                                    _precedingZeroWidthEntries_1 = precedingZeroWidthEntries;
                                    return [4 /*yield*/, {
                                            reader: function () {
                                                return startThread(value_1.reader(), _precedingZeroWidthEntries_1);
                                            },
                                            subType: value_1.subType,
                                            type: characterReaderLevel1TypeSplit,
                                        }];
                                case 11:
                                    _d.sent();
                                    return [3 /*break*/, 12];
                                case 12: return [2 /*return*/];
                            }
                        });
                    };
                    _a.label = 1;
                case 1:
                    if (!!(next = reader.next()).done) return [3 /*break*/, 3];
                    return [5 /*yield**/, _loop_1()];
                case 2:
                    state_1 = _a.sent();
                    if (typeof state_1 === "object")
                        return [2 /*return*/, state_1.value];
                    return [3 /*break*/, 1];
                case 3: return [2 /*return*/, { bounded: false, precedingZeroWidthEntries: precedingZeroWidthEntries }];
            }
        });
    };
    return startThread(buildCharacterReader({ caseInsensitive: caseInsensitive, dotAll: dotAll, node: node }), []);
}

var characterReaderLevel2TypeSplit = Symbol('characterReaderLevel2TypeSplit');
var characterReaderLevel2TypeEntry = Symbol('characterReaderLevel2TypeEntry');
// `InternalReader` is the same as `CharacterReaderLevel1`, except that the `stack` is `CharacterReaderLevel2Stack`
// which can include references
var internalReaderTypeSplit = Symbol('internalReaderTypeSplit');
var internalReaderTypeEntry = Symbol('internalReaderTypeEntry');
function characterReaderLevel1ToInternalReader(characterReaderLevel1) {
    var next, _loop_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _loop_1 = function () {
                    var value, _b;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                value = next.value;
                                _b = value.type;
                                switch (_b) {
                                    case characterReaderLevel1TypeSplit: return [3 /*break*/, 1];
                                    case characterReaderLevel1TypeEntry: return [3 /*break*/, 3];
                                }
                                return [3 /*break*/, 5];
                            case 1: return [4 /*yield*/, {
                                    reader: function () {
                                        return characterReaderLevel1ToInternalReader(value.reader());
                                    },
                                    subType: value.subType,
                                    type: internalReaderTypeSplit,
                                }];
                            case 2:
                                _c.sent();
                                return [3 /*break*/, 5];
                            case 3: return [4 /*yield*/, __assign(__assign({}, value), { type: internalReaderTypeEntry })];
                            case 4:
                                _c.sent();
                                return [3 /*break*/, 5];
                            case 5: return [2 /*return*/];
                        }
                    });
                };
                _a.label = 1;
            case 1:
                if (!!(next = characterReaderLevel1.next()).done) return [3 /*break*/, 3];
                return [5 /*yield**/, _loop_1()];
            case 2:
                _a.sent();
                return [3 /*break*/, 1];
            case 3: return [2 /*return*/, next.value];
        }
    });
}
function haveHadCompleteIteration(before, now) {
    var e_1, _a;
    try {
        for (var now_1 = __values(now), now_1_1 = now_1.next(); !now_1_1.done; now_1_1 = now_1.next()) {
            var _b = __read(now_1_1.value, 2), quantifier = _b[0], iterationsNow = _b[1];
            var iterationsBefore = before.get(quantifier) || 0;
            if (iterationsNow - iterationsBefore > 1) {
                return true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (now_1_1 && !now_1_1.done && (_a = now_1.return)) _a.call(now_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return false;
}
function getGroupContentsReader(_a) {
    var group, groupContents, groupLookaheadStack, _b, _c, groupEntry, e_2_1;
    var e_2, _d;
    var groupContentsStore = _a.groupContentsStore, groups = _a.groups, groupsWithInfiniteSize = _a.groupsWithInfiniteSize, nodeExtra = _a.nodeExtra, value = _a.value;
    return __generator(this, function (_e) {
        switch (_e.label) {
            case 0:
                group = mustGet(nodeExtra.indexToCapturingGroup, value.referenceIndex);
                groupContents = groupContentsStore.get(value.referenceIndex) || {
                    contents: [],
                    group: group,
                };
                groupLookaheadStack = dropCommon(mustGet(nodeExtra.nodeToLookaheadStack, groupContents.group), mustGet(nodeExtra.nodeToLookaheadStack, value.node)).a;
                if (groupLookaheadStack.length) {
                    if (groupLookaheadStack.some(function (_a) {
                        var behavior = _a.behavior;
                        return behavior === 'negativeLookahead' || behavior === 'negativeLookbehind';
                    })) {
                        return [2 /*return*/, { bounded: false, precedingZeroWidthEntries: [] }];
                    }
                    throw new Error("Unsupported reference (".concat(value.referenceIndex, " at position ").concat(value.node.range[0], "). Pattern needs downgrading. See the `downgradePattern` option."));
                }
                if (groups.has(groupContents.group) /* reference is inside group being referenced */) {
                    return [2 /*return*/, { bounded: false, precedingZeroWidthEntries: [] }];
                }
                if (groupsWithInfiniteSize.has(value.referenceIndex)) {
                    throw new Error("Unsupported reference to group ".concat(value.referenceIndex, " as group is not a finite size. Pattern needs downgrading. See the `downgradePattern` option."));
                }
                _e.label = 1;
            case 1:
                _e.trys.push([1, 6, 7, 8]);
                _b = __values(groupContents.contents), _c = _b.next();
                _e.label = 2;
            case 2:
                if (!!_c.done) return [3 /*break*/, 5];
                groupEntry = _c.value;
                return [4 /*yield*/, {
                        characterGroups: groupEntry.characterGroups,
                        node: groupEntry.node,
                        precedingZeroWidthEntries: groupEntry.precedingZeroWidthEntries,
                        stack: __spreadArray(__spreadArray(__spreadArray([], __read(groupEntry.stack), false), [
                            {
                                reference: value.node,
                                type: "reference",
                            }
                        ], false), __read(value.stack), false),
                        subType: 'groups',
                        type: internalReaderTypeEntry,
                    }];
            case 3:
                _e.sent();
                _e.label = 4;
            case 4:
                _c = _b.next();
                return [3 /*break*/, 2];
            case 5: return [3 /*break*/, 8];
            case 6:
                e_2_1 = _e.sent();
                e_2 = { error: e_2_1 };
                return [3 /*break*/, 8];
            case 7:
                try {
                    if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
                return [7 /*endfinally*/];
            case 8: return [2 /*return*/, { bounded: false, precedingZeroWidthEntries: [] }];
        }
    });
}
/**
 * Returns a `CharacterReaderLevel2` which builds on top of
 * `CharacterReaderLevel1` but replaces references with their
 * contents and includes the backreference stack.
 */
function buildCharacterReaderLevel2(_a) {
    var caseInsensitive = _a.caseInsensitive, dotAll = _a.dotAll, node = _a.node, nodeExtra = _a.nodeExtra;
    var startThread = function (state) {
        var _loop_2, state_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _loop_2 = function () {
                        var precedingZeroWidthEntries, groupsWithInfiniteSize, groupContentsStore, quantifierIterationsAtLastGroup, characterReader, referenceCharacterReaderWithReference, activeCharacterReader, result, value, _b, _groupContentsStore_1, _quantifierIterationsAtLastGroup_1, _groupsWithInfiniteSize_1, _precedingZeroWidthEntries_1, quantifierIterations, lookaheadStack, groups, _c, groupContentsReader, newGroupContentsStore, groupContentsStore_1, groupContentsStore_1_1, _d, index, group, offsets, offsets_1, offsets_1_1, offset, groupInfiniteSize, reversedStack, referenceStackIndex, noneReferenceStackPortion, _loop_3, noneReferenceStackPortion_1, noneReferenceStackPortion_1_1, stackEntry;
                        var e_3, _e, e_4, _f, e_5, _g;
                        return __generator(this, function (_h) {
                            switch (_h.label) {
                                case 0:
                                    precedingZeroWidthEntries = state.precedingZeroWidthEntries, groupsWithInfiniteSize = state.groupsWithInfiniteSize, groupContentsStore = state.groupContentsStore, quantifierIterationsAtLastGroup = state.quantifierIterationsAtLastGroup;
                                    characterReader = state.characterReader, referenceCharacterReaderWithReference = state.referenceCharacterReaderWithReference;
                                    activeCharacterReader = (referenceCharacterReaderWithReference === null || referenceCharacterReaderWithReference === void 0 ? void 0 : referenceCharacterReaderWithReference.reader) || characterReader;
                                    result = activeCharacterReader.next();
                                    if (result.done) {
                                        if (referenceCharacterReaderWithReference) {
                                            /* istanbul ignore next */
                                            if (result.value.bounded) {
                                                // for this to happen it means we must be inside a group (from a reference)
                                                // that contains `$`
                                                // but we should have stopped reading when the `$` was hit the first time
                                                // e.g `($)\1` should not reach the `\1`
                                                throw new Error('Internal error: end of reference reader cannot be bounded');
                                            }
                                            state = {
                                                characterReader: characterReader,
                                                groupContentsStore: groupContentsStore,
                                                groupsWithInfiniteSize: groupsWithInfiniteSize,
                                                precedingZeroWidthEntries: __spreadArray(__spreadArray([], __read(precedingZeroWidthEntries), false), __read(result.value.precedingZeroWidthEntries), false),
                                                quantifierIterationsAtLastGroup: quantifierIterationsAtLastGroup,
                                                referenceCharacterReaderWithReference: null,
                                            };
                                            return [2 /*return*/, "continue-outer"];
                                        }
                                        return [2 /*return*/, { value: {
                                                    bounded: result.value.bounded,
                                                    precedingZeroWidthEntries: __spreadArray(__spreadArray([], __read(precedingZeroWidthEntries), false), __read(result.value.precedingZeroWidthEntries), false),
                                                    type: 'end',
                                                } }];
                                    }
                                    value = result.value;
                                    _b = value.type;
                                    switch (_b) {
                                        case internalReaderTypeSplit: return [3 /*break*/, 1];
                                        case internalReaderTypeEntry: return [3 /*break*/, 3];
                                    }
                                    return [3 /*break*/, 7];
                                case 1:
                                    /* istanbul ignore next */
                                    if (referenceCharacterReaderWithReference) {
                                        throw new Error('Internal error: should not be seeing a split from a reference reader');
                                    }
                                    _groupContentsStore_1 = groupContentsStore;
                                    _quantifierIterationsAtLastGroup_1 = quantifierIterationsAtLastGroup;
                                    _groupsWithInfiniteSize_1 = groupsWithInfiniteSize;
                                    _precedingZeroWidthEntries_1 = precedingZeroWidthEntries;
                                    return [4 /*yield*/, {
                                            reader: function () {
                                                return startThread({
                                                    characterReader: buildForkableReader(value.reader()),
                                                    groupContentsStore: _groupContentsStore_1,
                                                    groupsWithInfiniteSize: _groupsWithInfiniteSize_1,
                                                    precedingZeroWidthEntries: _precedingZeroWidthEntries_1,
                                                    quantifierIterationsAtLastGroup: _quantifierIterationsAtLastGroup_1,
                                                    referenceCharacterReaderWithReference: referenceCharacterReaderWithReference,
                                                });
                                            },
                                            subType: value.subType,
                                            type: characterReaderLevel2TypeSplit,
                                        }];
                                case 2:
                                    _h.sent();
                                    return [3 /*break*/, 7];
                                case 3:
                                    precedingZeroWidthEntries = __spreadArray(__spreadArray([], __read(precedingZeroWidthEntries), false), __read(value.precedingZeroWidthEntries), false);
                                    quantifierIterations = buildQuantifierIterations(value.stack);
                                    lookaheadStack = getLookaheadStack(value.stack);
                                    groups = getGroups(value.stack);
                                    _c = value.subType;
                                    switch (_c) {
                                        case 'reference': return [3 /*break*/, 4];
                                        case 'groups': return [3 /*break*/, 5];
                                    }
                                    return [3 /*break*/, 7];
                                case 4:
                                    {
                                        /* istanbul ignore next */
                                        if (referenceCharacterReaderWithReference) {
                                            throw new Error('Internal error: should not be seeing a reference from a reference reader');
                                        }
                                        if (haveHadCompleteIteration(quantifierIterationsAtLastGroup, quantifierIterations)) {
                                            return [2 /*return*/, { value: {
                                                        type: 'abort',
                                                    } }];
                                        }
                                        groupContentsReader = buildForkableReader(getGroupContentsReader({
                                            groupContentsStore: groupContentsStore,
                                            groups: groups,
                                            groupsWithInfiniteSize: groupsWithInfiniteSize,
                                            nodeExtra: nodeExtra,
                                            value: value,
                                        }));
                                        state = {
                                            characterReader: characterReader,
                                            groupContentsStore: groupContentsStore,
                                            groupsWithInfiniteSize: groupsWithInfiniteSize,
                                            precedingZeroWidthEntries: precedingZeroWidthEntries,
                                            quantifierIterationsAtLastGroup: quantifierIterationsAtLastGroup,
                                            referenceCharacterReaderWithReference: {
                                                reader: groupContentsReader,
                                                reference: value.node,
                                            },
                                        };
                                        return [3 /*break*/, 7];
                                    }
                                case 5:
                                    newGroupContentsStore = new Map(groupContentsStore);
                                    if (!referenceCharacterReaderWithReference) {
                                        try {
                                            // Clear groups that are now ahead
                                            // This can happen when a quantifier containing a group restarts
                                            for (groupContentsStore_1 = (e_3 = void 0, __values(groupContentsStore)), groupContentsStore_1_1 = groupContentsStore_1.next(); !groupContentsStore_1_1.done; groupContentsStore_1_1 = groupContentsStore_1.next()) {
                                                _d = __read(groupContentsStore_1_1.value, 2), index = _d[0], group = _d[1].group;
                                                offsets = __spreadArray(__spreadArray([], __read(precedingZeroWidthEntries.map(function (_a) {
                                                    var offset = _a.offset;
                                                    return offset;
                                                })), false), [
                                                    value.node.range[0],
                                                ], false);
                                                try {
                                                    for (offsets_1 = (e_4 = void 0, __values(offsets)), offsets_1_1 = offsets_1.next(); !offsets_1_1.done; offsets_1_1 = offsets_1.next()) {
                                                        offset = offsets_1_1.value;
                                                        if (group.range[0] >= offset) {
                                                            newGroupContentsStore.delete(index);
                                                            break;
                                                        }
                                                    }
                                                }
                                                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                                                finally {
                                                    try {
                                                        if (offsets_1_1 && !offsets_1_1.done && (_f = offsets_1.return)) _f.call(offsets_1);
                                                    }
                                                    finally { if (e_4) throw e_4.error; }
                                                }
                                            }
                                        }
                                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                                        finally {
                                            try {
                                                if (groupContentsStore_1_1 && !groupContentsStore_1_1.done && (_e = groupContentsStore_1.return)) _e.call(groupContentsStore_1);
                                            }
                                            finally { if (e_3) throw e_3.error; }
                                        }
                                    }
                                    groupInfiniteSize = false;
                                    reversedStack = __spreadArray([], __read(value.stack), false).reverse();
                                    referenceStackIndex = reversedStack.findIndex(function (_a) {
                                        var type = _a.type;
                                        return type === 'reference';
                                    });
                                    noneReferenceStackPortion = reversedStack.slice(0, referenceStackIndex >= 0
                                        ? referenceStackIndex
                                        : value.stack.length);
                                    _loop_3 = function (stackEntry) {
                                        if (stackEntry.type === 'quantifier' &&
                                            stackEntry.quantifier.max === undefined) {
                                            groupInfiniteSize = true;
                                            return "continue";
                                        }
                                        else if (stackEntry.type !== 'group') {
                                            return "continue";
                                        }
                                        var group = stackEntry.group;
                                        if (group.behavior === 'lookbehind' ||
                                            group.behavior === 'negativeLookbehind' ||
                                            group.behavior === 'negativeLookahead' ||
                                            group.behavior === 'lookahead') {
                                            groupInfiniteSize = false;
                                            return "continue";
                                        }
                                        if (group.behavior !== 'normal') {
                                            return "continue";
                                        }
                                        var index = mustGet(nodeExtra.capturingGroupToIndex, group);
                                        if (groupInfiniteSize) {
                                            var newGroupsWithInfiniteSize = new Set(groupsWithInfiniteSize);
                                            newGroupsWithInfiniteSize.add(index);
                                            groupsWithInfiniteSize = newGroupsWithInfiniteSize;
                                        }
                                        var contents = newGroupContentsStore.get(index) || {
                                            contents: [],
                                            group: group,
                                        };
                                        newGroupContentsStore.set(index, __assign(__assign({}, contents), { contents: __spreadArray(__spreadArray([], __read(contents.contents), false), [
                                                __assign(__assign({}, value), { precedingZeroWidthEntries: precedingZeroWidthEntries.filter(function (_a) {
                                                        var offset = _a.offset;
                                                        // only include entries that are within the group
                                                        // e.g `^` in (^a) but not `^(a)`
                                                        return offset >= group.range[0] &&
                                                            offset <= group.range[1];
                                                    }) }),
                                            ], false) }));
                                    };
                                    try {
                                        for (noneReferenceStackPortion_1 = (e_5 = void 0, __values(noneReferenceStackPortion)), noneReferenceStackPortion_1_1 = noneReferenceStackPortion_1.next(); !noneReferenceStackPortion_1_1.done; noneReferenceStackPortion_1_1 = noneReferenceStackPortion_1.next()) {
                                            stackEntry = noneReferenceStackPortion_1_1.value;
                                            _loop_3(stackEntry);
                                        }
                                    }
                                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                                    finally {
                                        try {
                                            if (noneReferenceStackPortion_1_1 && !noneReferenceStackPortion_1_1.done && (_g = noneReferenceStackPortion_1.return)) _g.call(noneReferenceStackPortion_1);
                                        }
                                        finally { if (e_5) throw e_5.error; }
                                    }
                                    groupContentsStore = newGroupContentsStore;
                                    quantifierIterationsAtLastGroup = quantifierIterations;
                                    return [4 /*yield*/, {
                                            characterGroups: value.characterGroups,
                                            groups: groups,
                                            lookaheadStack: lookaheadStack,
                                            node: value.node,
                                            precedingZeroWidthEntries: precedingZeroWidthEntries,
                                            stack: value.stack,
                                            type: characterReaderLevel2TypeEntry,
                                        }];
                                case 6:
                                    _h.sent();
                                    precedingZeroWidthEntries = [];
                                    state = {
                                        characterReader: characterReader,
                                        groupContentsStore: groupContentsStore,
                                        groupsWithInfiniteSize: groupsWithInfiniteSize,
                                        precedingZeroWidthEntries: precedingZeroWidthEntries,
                                        quantifierIterationsAtLastGroup: quantifierIterationsAtLastGroup,
                                        referenceCharacterReaderWithReference: referenceCharacterReaderWithReference,
                                    };
                                    return [3 /*break*/, 7];
                                case 7: return [2 /*return*/];
                            }
                        });
                    };
                    _a.label = 1;
                case 1: return [5 /*yield**/, _loop_2()];
                case 2:
                    state_1 = _a.sent();
                    if (typeof state_1 === "object")
                        return [2 /*return*/, state_1.value];
                    switch (state_1) {
                        case "continue-outer": return [3 /*break*/, 3];
                    }
                    _a.label = 3;
                case 3: return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    };
    return startThread({
        characterReader: buildForkableReader(characterReaderLevel1ToInternalReader(buildCharacterReaderLevel1({ caseInsensitive: caseInsensitive, dotAll: dotAll, node: node }))),
        groupContentsStore: new Map(),
        groupsWithInfiniteSize: new Set(),
        precedingZeroWidthEntries: [],
        quantifierIterationsAtLastGroup: new Map(),
        referenceCharacterReaderWithReference: null,
    });
}

var InfiniteLoopTracker = /** @class */ (function () {
    function InfiniteLoopTracker(isEqual, source) {
        this._history = [];
        this._isEqual = isEqual;
        if (source) {
            this._history = __spreadArray([], __read(source.getHistory()), false);
        }
    }
    InfiniteLoopTracker.prototype._isEntryEqual = function (a, b) {
        return this._isEqual(a.left, b.left) && this._isEqual(a.right, b.right);
    };
    InfiniteLoopTracker.prototype.append = function (entry) {
        this._history.push(entry);
    };
    InfiniteLoopTracker.prototype.clone = function () {
        return new InfiniteLoopTracker(this._isEqual, this);
    };
    InfiniteLoopTracker.prototype.getHistory = function () {
        return __spreadArray([], __read(this._history), false);
    };
    InfiniteLoopTracker.prototype.getRepeatingEntries = function () {
        var length = this._history.length;
        outer: for (var candidateSize = 1; candidateSize <= length / 2; candidateSize++) {
            var candidateStart = length - candidateSize * 2;
            for (var i = 0; i < candidateSize; i++) {
                if (!this._isEntryEqual(this._history[candidateStart + i], this._history[candidateStart + candidateSize + i])) {
                    continue outer;
                }
            }
            return this._history.slice(candidateStart, candidateStart + candidateSize);
        }
        return null;
    };
    return InfiniteLoopTracker;
}());

function once(fn) {
    var done = false;
    var res;
    return function () {
        if (!done) {
            done = true;
            res = fn();
        }
        return res;
    };
}

var isUnboundedReaderTypeStep = Symbol('isUnboundedReaderTypeStep');
var notNewLine = {
    ranges: 
    // [\n\r\u2028-\u2029]
    [
        [10, 10],
        [13, 13],
        [8232, 8233],
    ],
    rangesNegated: true,
    unicodePropertyEscapes: new Map(),
};
/*
 * A reader that returns `true` if there could be nothing after the current
 * point  from the input reader.
 * I.e. anything that didn't match would fall outside the pattern
 * like the `b` in `aab` with pattern `^a+`
 */
function isUnboundedReader(_a) {
    var reader, stack, _loop_1, state_1;
    var multiLine = _a.multiLine, inputReader = _a.reader;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                reader = fork(inputReader);
                stack = [{ get: once(function () { return reader.next(); }), reader: reader }];
                _loop_1 = function () {
                    var frame, next, value, splitReader_1, isNewLine;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                frame = stack.pop();
                                if (!frame)
                                    return [2 /*return*/, "break"];
                                return [4 /*yield*/, {
                                        type: isUnboundedReaderTypeStep,
                                    }];
                            case 1:
                                _c.sent();
                                next = frame.get();
                                if (next.done) {
                                    if (next.value.type === 'end' && !next.value.bounded) {
                                        return [2 /*return*/, { value: true }];
                                    }
                                }
                                else {
                                    switch (next.value.type) {
                                        case characterReaderLevel2TypeSplit: {
                                            value = next.value;
                                            stack.push({
                                                get: once(function () { return frame.reader.next(); }),
                                                reader: frame.reader,
                                            });
                                            if (value.subType === null) {
                                                splitReader_1 = value.reader();
                                                stack.push({
                                                    get: once(function () { return splitReader_1.next(); }),
                                                    reader: splitReader_1,
                                                });
                                            }
                                            break;
                                        }
                                        case characterReaderLevel2TypeEntry: {
                                            if (multiLine) {
                                                isNewLine = isEmptyCharacterGroups(intersectCharacterGroups(notNewLine, next.value.characterGroups));
                                                if (isNewLine) {
                                                    stack.push({
                                                        get: once(function () { return frame.reader.next(); }),
                                                        reader: frame.reader,
                                                    });
                                                }
                                            }
                                            break;
                                        }
                                    }
                                }
                                return [2 /*return*/];
                        }
                    });
                };
                _b.label = 1;
            case 1: return [5 /*yield**/, _loop_1()];
            case 2:
                state_1 = _b.sent();
                if (typeof state_1 === "object")
                    return [2 /*return*/, state_1.value];
                if (state_1 === "break")
                    return [3 /*break*/, 4];
                _b.label = 3;
            case 3: return [3 /*break*/, 1];
            case 4: return [2 /*return*/, false];
        }
    });
}

function mergeSets(a, b) {
    return new Set(__spreadArray(__spreadArray([], __read(a), false), __read(b), false));
}
function areSetsEqual(a, b) {
    return a.size === b.size && mergeSets(a, b).size === a.size;
}

var checkerReaderTypeTrail = Symbol('checkerReaderTypeTrail');
var areInfiniteLoopTrackerEntriesEqual = function (left, right) {
    return left === right;
};
function buildContextTrail(stack, asteriskInfinite) {
    return stack
        .map(function (entry) {
        if (entry.type === 'quantifier') {
            return "q:".concat(entry.quantifier.range[0], ":").concat(asteriskInfinite &&
                entry.quantifier.max === undefined &&
                entry.iteration >= entry.quantifier.min
                ? '*'
                : "".concat(entry.iteration));
        }
        if (entry.type === 'reference') {
            return "r:".concat(entry.reference.range[0]);
        }
    })
        .filter(Boolean)
        .join(',');
}
/**
 * Takes a left and right `CharacterReaderLevel2` and runs them against each other.
 *
 * Emits a trail when left and right differ, as it means there are 2 different ways of matching the same
 * trail up to that point.
 */
function buildCheckerReader(input) {
    var trails, trailEntriesAtStartOfLoop, infiniteLoopTrackerEntryToTrailEntry, stepCount, latestEndTime, timedOut, infinite, initialLeftStreamReader, initialRightStreamReader, stack, _loop_1, state_1, trails_1, trails_1_1, trail, error;
    var e_1, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                trails = new Set();
                trailEntriesAtStartOfLoop = new Set();
                infiniteLoopTrackerEntryToTrailEntry = new Map();
                stepCount = 0;
                latestEndTime = Date.now() + input.timeout;
                timedOut = false;
                infinite = false;
                initialLeftStreamReader = buildForkableReader(input.leftStreamReader);
                initialRightStreamReader = buildForkableReader(input.rightStreamReader);
                stack = [
                    {
                        infiniteLoopTracker: new InfiniteLoopTracker(areInfiniteLoopTrackerEntriesEqual),
                        streamReadersWithGetters: [
                            {
                                get: once(function () { return initialLeftStreamReader.next(); }),
                                reader: initialLeftStreamReader,
                            },
                            {
                                get: once(function () { return initialRightStreamReader.next(); }),
                                reader: initialRightStreamReader,
                            },
                        ],
                        trail: [],
                    },
                ];
                _loop_1 = function () {
                    var entry, streamReadersWithGetters, infiniteLoopTracker, trail, nextValues, _loop_2, i, state_2, _c, leftNextValue, rightNextValue, leftValue, rightValue, leftPassedStartAnchor, rightPassedStartAnchor, somethingPassedStartAnchor, leftLookahead, rightLookahead, intersection, leftContextTrail, rightContextTrail, newEntry, leftQuantifiersInInfiniteProportion, leftAndRightIdentical, infiniteLoopTrackerEntry, repeatingEntries, entryAtStartOfLoop, leftAtomicGroups, rightAtomicGroups, sidesEqual, leftUnboundedReader, leftUnboundedCheckReaderNext, leftUnbounded, rightUnboundedReader, rightUnboundedCheckReaderNext, rightUnbounded, shouldEmitTrail;
                    return __generator(this, function (_d) {
                        switch (_d.label) {
                            case 0:
                                timedOut = Date.now() > latestEndTime;
                                if (timedOut || stepCount > input.maxSteps) {
                                    return [2 /*return*/, "break"];
                                }
                                entry = stack.pop();
                                if (!entry)
                                    return [2 /*return*/, "break"];
                                streamReadersWithGetters = entry.streamReadersWithGetters;
                                infiniteLoopTracker = entry.infiniteLoopTracker;
                                trail = entry.trail;
                                nextValues = [];
                                _loop_2 = function (i) {
                                    stepCount += 0.5;
                                    var result = streamReadersWithGetters[i].get();
                                    if (!result.done &&
                                        result.value.type === characterReaderLevel2TypeSplit) {
                                        var value_1 = result.value;
                                        stack.push({
                                            infiniteLoopTracker: infiniteLoopTracker,
                                            streamReadersWithGetters: streamReadersWithGetters.map(function (_a, j) {
                                                var reader = _a.reader, get = _a.get;
                                                return ({
                                                    get: j === i ? once(function () { return reader.next(); }) : get,
                                                    reader: reader,
                                                });
                                            }),
                                            trail: trail,
                                        });
                                        var newStreamReadersWithGetters = streamReadersWithGetters.map(function (_a, j) {
                                            var reader = _a.reader, get = _a.get;
                                            var newReader = j === i ? buildForkableReader(value_1.reader()) : fork(reader);
                                            return {
                                                get: j < i ? get : once(function () { return newReader.next(); }),
                                                reader: newReader,
                                            };
                                        });
                                        stack.push({
                                            infiniteLoopTracker: infiniteLoopTracker.clone(),
                                            streamReadersWithGetters: newStreamReadersWithGetters,
                                            trail: trail,
                                        });
                                        return "continue-outer";
                                    }
                                    else {
                                        nextValues.push(result);
                                    }
                                };
                                for (i = 0; i < streamReadersWithGetters.length; i++) {
                                    state_2 = _loop_2(i);
                                    switch (state_2) {
                                        case "continue-outer": return [2 /*return*/, state_2];
                                    }
                                }
                                _c = __read(nextValues, 2), leftNextValue = _c[0], rightNextValue = _c[1];
                                if (stepCount > input.maxSteps ||
                                    leftNextValue.done ||
                                    rightNextValue.done) {
                                    return [2 /*return*/, "continue"];
                                }
                                /* istanbul ignore next */
                                if (leftNextValue.value.type !== characterReaderLevel2TypeEntry ||
                                    rightNextValue.value.type !== characterReaderLevel2TypeEntry) {
                                    throw new Error('Internal error: impossible leftValue/rightValue type');
                                }
                                leftValue = leftNextValue.value;
                                rightValue = rightNextValue.value;
                                leftPassedStartAnchor = leftValue.precedingZeroWidthEntries.some(function (_a) {
                                    var type = _a.type;
                                    return type === 'start';
                                });
                                rightPassedStartAnchor = rightValue.precedingZeroWidthEntries.some(function (_a) {
                                    var type = _a.type;
                                    return type === 'start';
                                });
                                somethingPassedStartAnchor = leftPassedStartAnchor || rightPassedStartAnchor;
                                if (trail.length > 0 && somethingPassedStartAnchor) {
                                    return [2 /*return*/, "continue"];
                                }
                                leftLookahead = last(leftValue.lookaheadStack);
                                rightLookahead = last(rightValue.lookaheadStack);
                                if (leftLookahead !== rightLookahead) {
                                    return [2 /*return*/, "continue"];
                                }
                                intersection = intersectCharacterGroups(leftValue.characterGroups, rightValue.characterGroups);
                                if (isEmptyCharacterGroups(intersection)) {
                                    return [2 /*return*/, "continue"];
                                }
                                leftContextTrail = buildContextTrail(leftValue.stack, false);
                                rightContextTrail = buildContextTrail(rightValue.stack, false);
                                newEntry = {
                                    intersection: intersection,
                                    left: {
                                        characterGroups: leftValue.characterGroups,
                                        contextTrail: leftContextTrail,
                                        hash: [leftValue.node.range[0], leftContextTrail].join(':'),
                                        node: leftValue.node,
                                        stack: leftValue.stack,
                                    },
                                    right: {
                                        characterGroups: rightValue.characterGroups,
                                        contextTrail: rightContextTrail,
                                        hash: [rightValue.node.range[0], rightContextTrail].join(':'),
                                        node: rightValue.node,
                                        stack: rightValue.stack,
                                    },
                                };
                                trail = __spreadArray(__spreadArray([], __read(trail), false), [newEntry], false);
                                leftQuantifiersInInfiniteProportion = buildQuantifiersInInfinitePortion(leftValue.stack, input.nodeExtra);
                                if (leftQuantifiersInInfiniteProportion.size > 0) {
                                    leftAndRightIdentical = trail.every(function (_a) {
                                        var left = _a.left, right = _a.right;
                                        return left.hash === right.hash;
                                    });
                                    if (leftAndRightIdentical) {
                                        return [2 /*return*/, "continue"];
                                    }
                                }
                                infiniteLoopTrackerEntry = {
                                    left: [
                                        leftValue.node.range[0],
                                        buildContextTrail(leftValue.stack, true),
                                    ].join(':'),
                                    right: [
                                        rightValue.node.range[0],
                                        buildContextTrail(leftValue.stack, true),
                                    ].join(':'),
                                };
                                infiniteLoopTrackerEntryToTrailEntry.set(infiniteLoopTrackerEntry, newEntry);
                                infiniteLoopTracker.append(infiniteLoopTrackerEntry);
                                repeatingEntries = infiniteLoopTracker.getRepeatingEntries();
                                if (repeatingEntries) {
                                    entryAtStartOfLoop = infiniteLoopTrackerEntryToTrailEntry.get(repeatingEntries[0]);
                                    /* istanbul ignore next */
                                    if (!entryAtStartOfLoop) {
                                        throw new Error('Internal error: missing entry at start of loop');
                                    }
                                    trailEntriesAtStartOfLoop.add(entryAtStartOfLoop);
                                    return [2 /*return*/, "continue"];
                                }
                                leftAtomicGroups = new Set(__spreadArray([], __read(leftValue.groups.keys()), false).filter(function (group) {
                                    return input.atomicGroupOffsets.has(group.range[0]);
                                }));
                                rightAtomicGroups = new Set(__spreadArray([], __read(rightValue.groups.keys()), false).filter(function (group) {
                                    return input.atomicGroupOffsets.has(group.range[0]);
                                }));
                                if (!areSetsEqual(leftAtomicGroups, rightAtomicGroups)) {
                                    return [2 /*return*/, "continue"];
                                }
                                sidesEqual = newEntry.left.hash === newEntry.right.hash;
                                if (!!sidesEqual) return [3 /*break*/, 2];
                                {
                                    leftUnboundedReader = isUnboundedReader({
                                        multiLine: input.multiLine,
                                        reader: fork(streamReadersWithGetters[0].reader),
                                    });
                                    leftUnboundedCheckReaderNext = void 0;
                                    while (!(leftUnboundedCheckReaderNext = leftUnboundedReader.next()).done) {
                                        switch (leftUnboundedCheckReaderNext.value.type) {
                                            case isUnboundedReaderTypeStep: {
                                                stepCount += 0.5;
                                                if (stepCount > input.maxSteps) {
                                                    return [2 /*return*/, "break-outer"];
                                                }
                                                break;
                                            }
                                        }
                                    }
                                    leftUnbounded = leftUnboundedCheckReaderNext.value;
                                    if (leftUnbounded)
                                        return [2 /*return*/, "continue"];
                                }
                                {
                                    rightUnboundedReader = isUnboundedReader({
                                        multiLine: input.multiLine,
                                        reader: fork(streamReadersWithGetters[1].reader),
                                    });
                                    rightUnboundedCheckReaderNext = void 0;
                                    while (!(rightUnboundedCheckReaderNext = rightUnboundedReader.next()).done) {
                                        switch (rightUnboundedCheckReaderNext.value.type) {
                                            case isUnboundedReaderTypeStep: {
                                                stepCount += 0.5;
                                                /* istanbul ignore next */
                                                if (stepCount > input.maxSteps) {
                                                    return [2 /*return*/, "break-outer"];
                                                }
                                                break;
                                            }
                                        }
                                    }
                                    rightUnbounded = rightUnboundedCheckReaderNext.value;
                                    if (rightUnbounded)
                                        return [2 /*return*/, "continue"];
                                }
                                shouldEmitTrail = function () {
                                    var alreadyExists = __spreadArray([], __read(trails), false).some(function (existingTrail) {
                                        if (existingTrail.length !== trail.length)
                                            return false;
                                        return (existingTrail.every(function (existingEntry, i) {
                                            return existingEntry.left.hash === trail[i].right.hash &&
                                                existingEntry.right.hash === trail[i].left.hash;
                                        }) ||
                                            existingTrail.every(function (existingEntry, i) {
                                                return existingEntry.left.hash === trail[i].left.hash &&
                                                    existingEntry.right.hash === trail[i].right.hash;
                                            }));
                                    });
                                    return !alreadyExists;
                                };
                                if (!shouldEmitTrail()) return [3 /*break*/, 2];
                                trails.add(trail);
                                return [4 /*yield*/, { trail: trail, type: checkerReaderTypeTrail }];
                            case 1:
                                _d.sent();
                                _d.label = 2;
                            case 2:
                                stack.push({
                                    infiniteLoopTracker: infiniteLoopTracker,
                                    streamReadersWithGetters: streamReadersWithGetters.map(function (_a) {
                                        var reader = _a.reader;
                                        return ({
                                            get: once(function () { return reader.next(); }),
                                            reader: reader,
                                        });
                                    }),
                                    trail: trail,
                                });
                                return [2 /*return*/];
                        }
                    });
                };
                _b.label = 1;
            case 1: return [5 /*yield**/, _loop_1()];
            case 2:
                state_1 = _b.sent();
                if (state_1 === "break")
                    return [3 /*break*/, 4];
                switch (state_1) {
                    case "break-outer": return [3 /*break*/, 4];
                    case "continue-outer": return [3 /*break*/, 3];
                }
                _b.label = 3;
            case 3: return [3 /*break*/, 1];
            case 4:
                if (trailEntriesAtStartOfLoop.size > 0) {
                    try {
                        for (trails_1 = __values(trails), trails_1_1 = trails_1.next(); !trails_1_1.done; trails_1_1 = trails_1.next()) {
                            trail = trails_1_1.value;
                            if (trail.some(function (entry) { return trailEntriesAtStartOfLoop.has(entry); })) {
                                infinite = true;
                                break;
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (trails_1_1 && !trails_1_1.done && (_a = trails_1.return)) _a.call(trails_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                error = stepCount > input.maxSteps
                    ? 'hitMaxSteps'
                    : timedOut
                        ? 'timedOut'
                        : null;
                return [2 /*return*/, error
                        ? {
                            error: error,
                        }
                        : { error: null, infinite: infinite }];
        }
    });
}

var lookaheadBehaviours = [
    'lookahead',
    'lookbehind',
    'negativeLookahead',
    'negativeLookbehind',
];
function buildNodeExtra(regexp) {
    var capturingGroupToIndex = new Map();
    var indexToCapturingGroup = new Map();
    var nodeToLookaheadStack = new Map();
    var reachableReferences = [];
    var visit = function (node, lookaheadStack, reachable) {
        switch (node.type) {
            case 'anchor':
            case 'characterClass':
            case 'characterClassEscape':
            case 'characterClassRange':
            case 'unicodePropertyEscape':
            case 'value':
            case 'dot':
                return;
            case 'reference': {
                nodeToLookaheadStack.set(node, lookaheadStack);
                if (reachable)
                    reachableReferences.push(node);
                break;
            }
            case 'alternative':
            case 'disjunction': {
                node.body.forEach(function (expression) {
                    return visit(expression, lookaheadStack, reachable);
                });
                return;
            }
            case 'group': {
                if (node.behavior === 'normal') {
                    var index = capturingGroupToIndex.size + 1;
                    capturingGroupToIndex.set(node, index);
                    indexToCapturingGroup.set(index, node);
                    nodeToLookaheadStack.set(node, lookaheadStack);
                }
                var newLookaheadStack_1 = __spreadArray([], __read(lookaheadStack), false);
                if (node.behavior !== 'normal' &&
                    lookaheadBehaviours.indexOf(node.behavior) >= 0) {
                    newLookaheadStack_1.push(node);
                }
                node.body.forEach(function (expression) {
                    return visit(expression, newLookaheadStack_1, reachable);
                });
                return;
            }
            case 'quantifier': {
                node.body.forEach(function (expression) {
                    return visit(expression, lookaheadStack, reachable && node.max !== 0);
                });
                return;
            }
        }
    };
    visit(regexp, [], true);
    return {
        capturingGroupToIndex: capturingGroupToIndex,
        indexToCapturingGroup: indexToCapturingGroup,
        nodeToLookaheadStack: nodeToLookaheadStack,
        reachableReferences: reachableReferences,
    };
}

var ResultCache = /** @class */ (function () {
    function ResultCache() {
        this._cache = new Map();
    }
    ResultCache.prototype.addResult = function (a, b, result) {
        var mapA = this._cache.get(a) || new Map();
        mapA.set(b, result);
        this._cache.set(a, mapA);
        var mapB = this._cache.get(b) || new Map();
        mapB.set(a, result);
        this._cache.set(b, mapB);
    };
    ResultCache.prototype.getResult = function (a, b) {
        var _a;
        return (_a = this._cache.get(a)) === null || _a === void 0 ? void 0 : _a.get(b);
    };
    return ResultCache;
}());

var rootSymbol = Symbol('root');
var Tree = /** @class */ (function () {
    function Tree(decode) {
        this.decode = decode;
        this.root = new Map();
        this.results = new Map();
        this._items = function () { return []; };
    }
    Tree.prototype.add = function (input) {
        var values = this.decode(input);
        if (values.length === 0)
            return;
        var results = this.results;
        var current = {
            children: this.root,
            value: rootSymbol,
        };
        // note initially used `.entries()` but this was much slower
        var numValues = values.length;
        for (var i = 0; i < numValues; i++) {
            var value = values[i];
            var last = i === numValues - 1;
            var existing = current.children.get(value);
            if (existing) {
                current = existing;
                if (!last) {
                    results.delete(existing);
                }
            }
            else {
                var newChild = { children: new Map(), value: value };
                current.children.set(value, newChild);
                current = newChild;
                if (last) {
                    results.set(newChild, input);
                }
            }
        }
        this._items = once(function () { return Array.from(results.values()); });
    };
    Object.defineProperty(Tree.prototype, "items", {
        get: function () {
            return this._items();
        },
        enumerable: false,
        configurable: true
    });
    return Tree;
}());

var workLimit = 25000;
var EnhancedTrail = /** @class */ (function () {
    function EnhancedTrail(trail, isEmptyCache) {
        this.trail = trail;
        this.isEmptyCache = isEmptyCache;
        this.tree = new Tree(function (trail) {
            return trail.map(function (_a) {
                var hash = _a.hash;
                return hash;
            });
        });
        this.inputStringSchema = trail.map(function (_a) {
            var intersection = _a.intersection;
            return intersection;
        });
        this.length = trail.length;
        this.onNewTrail(this);
    }
    Object.defineProperty(EnhancedTrail.prototype, "matches", {
        get: function () {
            return this.tree.items;
        },
        enumerable: false,
        configurable: true
    });
    EnhancedTrail.prototype.getLongestMatch = function (inputStringSchema, trailSides) {
        var _this = this;
        /* istanbul ignore next */
        if (trailSides.length > inputStringSchema.length) {
            throw new Error('Internal error: trail should be <= than input string schema');
        }
        var noMatchOffset = trailSides.findIndex(function (side, i) {
            var res = _this.isEmptyCache.getResult(side.characterGroups, inputStringSchema[i]);
            if (res !== undefined)
                return res;
            var isEmpty = isEmptyCharacterGroups(intersectCharacterGroups(side.characterGroups, inputStringSchema[i]));
            _this.isEmptyCache.addResult(side.characterGroups, inputStringSchema[i], isEmpty);
            return isEmpty;
        });
        return noMatchOffset === -1
            ? trailSides
            : trailSides.slice(0, noMatchOffset);
    };
    EnhancedTrail.prototype.onNewTrail = function (otherTrail) {
        var e_1, _a;
        var leftSide = [];
        var rightSide = [];
        try {
            for (var _b = __values(otherTrail.trail), _c = _b.next(); !_c.done; _c = _b.next()) {
                var entry = _c.value;
                leftSide.push(entry.left);
                rightSide.push(entry.right);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var leftMatch = this.getLongestMatch(this.inputStringSchema, leftSide);
        if (leftMatch.length === this.length)
            this.tree.add(leftMatch);
        var rightMatch = this.getLongestMatch(this.inputStringSchema, rightSide);
        if (rightMatch.length === this.length)
            this.tree.add(rightMatch);
    };
    return EnhancedTrail;
}());
function collectResults(_a) {
    var e_2, _b;
    var atomicGroupOffsets = _a.atomicGroupOffsets, node = _a.node, maxScore = _a.maxScore, maxSteps = _a.maxSteps, multiLine = _a.multiLine, timeout = _a.timeout, caseInsensitive = _a.caseInsensitive, dotAll = _a.dotAll;
    var isEmptyCache = new ResultCache();
    var nodeExtra = buildNodeExtra(node);
    var input = {
        caseInsensitive: caseInsensitive,
        dotAll: dotAll,
        node: node,
        nodeExtra: nodeExtra,
    };
    var leftStreamReader = buildCharacterReaderLevel2(input);
    var rightStreamReader = buildCharacterReaderLevel2(input);
    var reader = buildCheckerReader({
        atomicGroupOffsets: atomicGroupOffsets,
        leftStreamReader: leftStreamReader,
        maxSteps: maxSteps,
        multiLine: multiLine,
        nodeExtra: nodeExtra,
        rightStreamReader: rightStreamReader,
        timeout: timeout,
    });
    var trailsTree = new Tree(function (_a) {
        var trail = _a.trail;
        return trail;
    });
    var score = 1;
    var work = 0;
    var next;
    outer: while (!(next = reader.next()).done) {
        switch (next.value.type) {
            case checkerReaderTypeTrail: {
                var trail = new EnhancedTrail(next.value.trail, isEmptyCache);
                var updateScore = function (_a) {
                    var matches = _a.matches;
                    var length = matches.length;
                    if (length > score) {
                        score = length;
                    }
                };
                if (work < workLimit) {
                    try {
                        for (var _c = (e_2 = void 0, __values(trailsTree.items)), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var existingTrail = _d.value;
                            if (existingTrail.length === trail.length) {
                                work += trail.length;
                                if (work >= workLimit)
                                    break;
                                trail.onNewTrail(existingTrail);
                                existingTrail.onNewTrail(trail);
                                updateScore(existingTrail);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    updateScore(trail);
                }
                if (work >= workLimit) {
                    // it's too costly to continue calculating an accurate count, so fall back to assuming the input string that matches the largest
                    // group of trails would also match every new trail
                    score += 1;
                }
                trailsTree.add(trail);
                if (score > maxScore) {
                    break outer;
                }
                break;
            }
        }
    }
    var error = null;
    if (next.done) {
        if (next.value.error) {
            score = Infinity;
            error = next.value.error;
        }
        else if (next.value.infinite) {
            score = Infinity;
            error = 'hitMaxScore';
        }
    }
    else {
        score = Infinity;
        error = 'hitMaxScore';
    }
    return {
        error: error,
        score: score,
        trails: trailsTree.items.map(function (_a) {
            var trail = _a.trail;
            return trail;
        }),
    };
}

var truncateLength = 100;
var defaultResultsLimit = 15;
function getBreadcrumbs(side) {
    return "".concat(__spreadArray(__spreadArray([], __read(side.backreferenceStack.map(function (_a) {
        var node = _a.node;
        return node.start.offset;
    }).reverse()), false), [
        side.node.start.offset,
    ], false).join("\u2192"));
}
/**
 * Takes a result and converts it to a text representation.
 *
 * Do not try and parse this string programmatically. It may change
 * between any version.
 */
function toFriendly(result, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.resultsLimit, resultsLimit = _c === void 0 ? defaultResultsLimit : _c, _d = _b.alwaysIncludeTrails, alwaysIncludeTrails = _d === void 0 ? false : _d;
    if (resultsLimit < 0) {
        throw new Error('`resultsLimit` must be > 0.');
    }
    var scoreString = result.score.infinite
        ? 'There could be infinite backtracks.'
        : "Score: ".concat(result.score.value);
    if (result.safe && !alwaysIncludeTrails) {
        return "Regex is safe. ".concat(scoreString);
    }
    var outputLines = [];
    if (result.patternDowngraded) {
        outputLines.push("Pattern was downgraded to `".concat(result.pattern, "`."));
    }
    if (!result.trails.length) {
        var parts = [];
        parts.push(result.safe ? 'Regex is safe.' : 'Regex may not be safe.');
        if (result.error === 'timedOut') {
            parts.push("Timed out.");
        }
        if (result.error === 'hitMaxSteps') {
            parts.push("Reached steps limit.");
        }
        if (!result.safe) {
            parts.push("The pattern may have too many variations.");
        }
        outputLines.push(parts.join(' '));
    }
    else {
        var resultBlocks = result.trails
            .slice(0, resultsLimit)
            .map(function (_a) {
            var trail = _a.trail;
            var rowContents = trail.slice(0, truncateLength).map(function (_a) {
                var a = _a.a, b = _a.b;
                return [
                    getBreadcrumbs(a),
                    "`".concat(a.node.source, "`"),
                    getBreadcrumbs(b),
                    "`".concat(b.node.source, "`"),
                ];
            });
            var maxCol1Length = Math.max.apply(Math, __spreadArray([], __read(rowContents.map(function (_a) {
                var _b = __read(_a, 1), col = _b[0];
                return col.length;
            })), false));
            var maxCol2Length = Math.max.apply(Math, __spreadArray([], __read(rowContents.map(function (_a) {
                var _b = __read(_a, 2), col = _b[1];
                return col.length;
            })), false));
            var maxCol3Length = Math.max.apply(Math, __spreadArray([], __read(rowContents.map(function (_a) {
                var _b = __read(_a, 3), col = _b[2];
                return col.length;
            })), false));
            var rows = rowContents.map(function (_a) {
                var _b = __read(_a, 4), col1 = _b[0], col2 = _b[1], col3 = _b[2], col4 = _b[3];
                return "".concat(col1.padStart(maxCol1Length), ": ").concat(col2.padEnd(maxCol2Length), " | ").concat(col3.padStart(maxCol3Length), ": ").concat(col4);
            });
            if (trail.length > truncateLength) {
                rows.push('…');
            }
            var maxRowLength = Math.max.apply(Math, __spreadArray([], __read(rows.map(function (row) { return row.length; })), false));
            rows.push('='.repeat(maxRowLength));
            return rows.join('\n');
        });
        var errorToMessage = {
            hitMaxScore: 'Hit the max score so there may be more results than shown here.',
            hitMaxSteps: 'Hit maximum number of steps so there may be more results than shown here.',
            timedOut: 'Timed out so there may be more results than shown here.',
        };
        outputLines.push.apply(outputLines, __spreadArray([], __read(__spreadArray([
            "Regex is ".concat(!result.safe ? 'not ' : '', "safe. ").concat(scoreString)
        ], __read((resultsLimit > 0
            ? __spreadArray(__spreadArray(__spreadArray(__spreadArray([
                '',
                "The following trail".concat(result.trails.length > 1 ? 's' : '', " show").concat(result.trails.length === 1 ? 's' : '', " how the same input can be matched multiple ways.")
            ], __read(resultBlocks), false), [
                ''
            ], false), __read((result.error ? [errorToMessage[result.error]] : [])), false), __read((result.trails.length > resultsLimit
                ? ['There are more results than this but hit results limit.']
                : [])), false) : [])), false)), false));
    }
    return outputLines.join('\n');
}

/**
 * The current version.
 */
var version = _version;
var defaultTimeout = Infinity;
var defaultMaxScore = 200;
var defaultMaxSteps = 20000;
var defaultMultiLine = false;
var defaultUnicode = false;
var defaultCaseInsensitive = false;
var defaultDotAll = false;
var supportedJSFlags = new Set([
    'u',
    'g',
    's',
    'y',
    'i',
    'd',
    'm',
]);
function toRedosDetectorNode(node) {
    return {
        end: { offset: node.range[1] },
        source: node.raw,
        start: { offset: node.range[0] },
    };
}
function toRedosDetectorBackReferenceStack(stack) {
    return stack
        .flatMap(function (stackEntry) {
        return stackEntry.type === 'reference' ? [stackEntry.reference] : [];
    })
        .reverse()
        .map(function (reference) {
        return {
            index: reference.matchIndex,
            node: toRedosDetectorNode(reference),
        };
    });
}
function toRedosDetectorQuantifierIterations(stack) {
    var reversedStack = __spreadArray([], __read(stack), false).reverse();
    var referenceStackIndex = reversedStack.findIndex(function (_a) {
        var type = _a.type;
        return type === 'reference';
    });
    var noneReferenceStackPortion = reversedStack
        .slice(0, referenceStackIndex >= 0 ? referenceStackIndex : stack.length)
        .reverse();
    return noneReferenceStackPortion
        .flatMap(function (entry) { return (entry.type === 'quantifier' ? [entry] : []); })
        .map(function (_a) {
        var quantifier = _a.quantifier, iteration = _a.iteration;
        return {
            iteration: iteration,
            node: toRedosDetectorNode(quantifier),
        };
    });
}
/**
 * Check if the provided input pattern is not susceptible to ReDoS attacks.
 *
 * Can be configured with various options in the second argument.
 */
function isSafePattern(inputPattern, _a) {
    var _b = _a === void 0 ? {} : _a, atomicGroupOffsetsInput = _b.atomicGroupOffsets, _c = _b.maxScore, maxScore = _c === void 0 ? defaultMaxScore : _c, _d = _b.maxSteps, maxSteps = _d === void 0 ? defaultMaxSteps : _d, _e = _b.multiLine, multiLine = _e === void 0 ? defaultMultiLine : _e, _f = _b.timeout, timeout = _f === void 0 ? defaultTimeout : _f, _g = _b.caseInsensitive, caseInsensitive = _g === void 0 ? defaultCaseInsensitive : _g, _h = _b.dotAll, dotAll = _h === void 0 ? defaultDotAll : _h, _j = _b.unicode, unicode = _j === void 0 ? defaultUnicode : _j, _k = _b.downgradePattern, downgradePattern$1 = _k === void 0 ? true : _k;
    if (caseInsensitive && unicode) {
        // https://mathiasbynens.be/notes/es6-unicode-regex
        throw new Error('`caseInsensitive` cannot be used with `unicode`.');
    }
    if (downgradePattern$1 && atomicGroupOffsetsInput) {
        throw new Error('`atomicGroupOffsets` cannot be used with `downgradePattern: true`.');
    }
    if (timeout <= 0) {
        throw new Error('`timeout` must be a positive number.');
    }
    if (maxScore < 0) {
        throw new Error('`maxScore` must be a positive number or 0.');
    }
    if (maxSteps <= 0) {
        throw new Error('`maxSteps` must be a positive number.');
    }
    var _l = downgradePattern$1
        ? downgradePattern({ pattern: inputPattern, unicode: unicode })
        : {
            atomicGroupOffsets: new Set(atomicGroupOffsetsInput || []),
            pattern: inputPattern,
        }, pattern = _l.pattern, atomicGroupOffsets = _l.atomicGroupOffsets;
    var patternDowngraded = downgradePattern$1 && inputPattern !== pattern;
    var ast = parse(pattern, unicode);
    if (!downgradePattern$1 && isMissingStartAnchor(ast)) {
        throw new Error('Pattern is not bounded at the start and needs downgrading. See the `downgradePattern` option.');
    }
    var result = collectResults({
        atomicGroupOffsets: atomicGroupOffsets,
        caseInsensitive: caseInsensitive,
        dotAll: dotAll,
        maxScore: maxScore,
        maxSteps: maxSteps,
        multiLine: multiLine,
        node: ast,
        timeout: timeout,
    });
    return __assign(__assign({}, (result.error
        ? {
            error: result.error,
            safe: false,
        }
        : {
            error: null,
            safe: true,
        })), { pattern: pattern, patternDowngraded: patternDowngraded, score: result.score === Infinity
            ? { infinite: true }
            : { infinite: false, value: result.score }, trails: result.trails.map(function (trail) {
            var safeRegexTrail = {
                trail: trail.map(function (_a) {
                    var left = _a.left, right = _a.right;
                    var entry = {
                        a: {
                            backreferenceStack: toRedosDetectorBackReferenceStack(right.stack),
                            node: toRedosDetectorNode(right.node),
                            quantifierIterations: toRedosDetectorQuantifierIterations(right.stack),
                        },
                        b: {
                            backreferenceStack: toRedosDetectorBackReferenceStack(left.stack),
                            node: toRedosDetectorNode(left.node),
                            quantifierIterations: toRedosDetectorQuantifierIterations(left.stack),
                        },
                    };
                    return entry;
                }),
            };
            return safeRegexTrail;
        }) });
}
/**
 * Check if the provided regular expression object is not susceptible to ReDoS attacks.
 *
 * Can be configured with various options in the second argument.
 */
function isSafe(regexp, config) {
    var e_1, _a;
    var unicode = false;
    var caseInsensitive = false;
    var dotAll = false;
    var multiLine = false;
    try {
        for (var _b = __values(regexp.flags.split('')), _c = _b.next(); !_c.done; _c = _b.next()) {
            var flag = _c.value;
            if (!supportedJSFlags.has(flag)) {
                throw new Error("Unsupported flag: ".concat(flag));
            }
            if (flag === 'u')
                unicode = true;
            if (flag === 'i')
                caseInsensitive = true;
            if (flag === 's')
                dotAll = true;
            if (flag === 'm')
                multiLine = true;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return isSafePattern(regexp.source, __assign(__assign({}, config), { caseInsensitive: caseInsensitive, dotAll: dotAll, multiLine: multiLine, unicode: unicode }));
}

export { defaultCaseInsensitive, defaultDotAll, defaultMaxScore, defaultMaxSteps, defaultMultiLine, defaultResultsLimit, defaultTimeout, defaultUnicode, downgradePattern, isSafe, isSafePattern, toFriendly, version };
